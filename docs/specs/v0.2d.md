# v0.2d Specification

> Orchestrator Actor Pattern & Non-Blocking UI

**Status**: Planned  
**Target**: Fully responsive UI with actor-based orchestration and request queuing

---

## Overview

v0.2d refactors the core architecture to use an actor pattern for the orchestrator. This eliminates UI blocking during LLM and database operations, enables request queuing, and provides clear visual feedback for all operation states. The orchestrator runs in a dedicated task, communicating with the TUI via message channels.

This supersedes the background task approach outlined in v0.2c FR-1, providing a cleaner separation of concerns and natural request management.

---

## User Stories

### US-1: Responsive UI During Operations

> As a user, I want the UI to remain fully responsive while waiting for LLM or database responses.

**Acceptance Criteria:**

- Spinner animations update smoothly during operations
- Can scroll chat history while waiting
- Can switch panel focus while waiting
- Can type new input while waiting (queued or blocked based on mode)
- UI never freezes or becomes unresponsive

### US-2: Clear Operation Status

> As a user, I want to clearly see what operation is in progress and its current state.

**Acceptance Criteria:**

- Visual indicator shows current operation phase (thinking, executing, etc.)
- Progress appears inline in chat where result will appear
- Can distinguish between LLM thinking vs database executing
- Time elapsed shown for long operations

### US-3: Request Queuing

> As a user, I want to queue additional requests while one is processing so I can work ahead.

**Acceptance Criteria:**

- Can submit new input while operation is in progress
- Queued requests shown in UI with position indicator
- Can cancel individual queued requests
- Queue processes in order (FIFO)
- Maximum queue depth prevents runaway

### US-4: Operation Cancellation

> As a user, I want to cancel in-flight operations without losing my place.

**Acceptance Criteria:**

- Esc cancels current operation
- Cancelled operations show "Cancelled" status in chat
- Queued requests remain after cancelling current
- Can cancel all (current + queue) with Ctrl+C
- Partial results preserved if available

---

## Architecture

### Actor Model Overview

```
┌─────────────────────────────────────────────────────────────────┐
│                         TUI Event Loop                          │
│  ┌─────────────┐    ┌─────────────┐    ┌─────────────────────┐  │
│  │ Event       │───▶│ App State   │───▶│ Render              │  │
│  │ Handler     │    │ (UI only)   │    │                     │  │
│  └─────────────┘    └─────────────┘    └─────────────────────┘  │
│         │                  ▲                                    │
│         │                  │                                    │
│         ▼                  │                                    │
│  ┌─────────────┐    ┌─────────────┐                             │
│  │ Command TX  │    │ Response RX │                             │
│  └──────┬──────┘    └──────┬──────┘                             │
└─────────┼──────────────────┼────────────────────────────────────┘
          │                  │
          ▼                  │
┌─────────────────────────────────────────────────────────────────┐
│                    Orchestrator Actor Task                      │
│  ┌─────────────┐    ┌─────────────┐    ┌─────────────────────┐  │
│  │ Command RX  │───▶│ Request     │───▶│ LLM / DB            │  │
│  │             │    │ Queue       │    │ Operations          │  │
│  └─────────────┘    └─────────────┘    └─────────────────────┘  │
│                            │                    │               │
│                            ▼                    ▼               │
│                     ┌─────────────┐    ┌─────────────────────┐  │
│                     │ Response TX │◀───│ Progress Updates    │  │
│                     └─────────────┘    └─────────────────────┘  │
└─────────────────────────────────────────────────────────────────┘
```

### Message Types

#### Commands (TUI → Orchestrator)

```rust
/// Commands sent from TUI to orchestrator actor.
pub enum OrchestratorCommand {
    /// Process user input (natural language or command).
    ProcessInput {
        id: RequestId,
        input: String,
    },
    /// Execute SQL directly (from /sql command).
    ExecuteSql {
        id: RequestId,
        sql: String,
    },
    /// Confirm a pending mutation query.
    ConfirmQuery {
        id: RequestId,
        sql: String,
    },
    /// Cancel the current operation.
    CancelCurrent,
    /// Cancel a specific queued request.
    CancelRequest(RequestId),
    /// Cancel all operations (current + queued).
    CancelAll,
    /// Shutdown the orchestrator.
    Shutdown,
}

/// Unique identifier for a request.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct RequestId(u64);
```

#### Responses (Orchestrator → TUI)

```rust
/// Responses sent from orchestrator to TUI.
pub enum OrchestratorResponse {
    /// Request was queued (not yet processing).
    Queued {
        id: RequestId,
        position: usize,
    },
    /// Request started processing.
    Started {
        id: RequestId,
        phase: OperationPhase,
    },
    /// Progress update for current operation.
    Progress {
        id: RequestId,
        phase: OperationPhase,
        elapsed: Duration,
        detail: Option<String>,
    },
    /// Operation completed successfully.
    Completed {
        id: RequestId,
        result: InputResult,
    },
    /// Operation failed with error.
    Failed {
        id: RequestId,
        error: String,
    },
    /// Operation was cancelled.
    Cancelled {
        id: RequestId,
    },
    /// Query needs user confirmation before execution.
    NeedsConfirmation {
        id: RequestId,
        sql: String,
        classification: ClassificationResult,
    },
    /// Queue status changed.
    QueueUpdate {
        queue_depth: usize,
        current: Option<RequestId>,
    },
}

/// Current phase of an operation.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum OperationPhase {
    /// Waiting in queue.
    Queued,
    /// Sending request to LLM.
    LlmRequesting,
    /// Waiting for LLM response.
    LlmThinking,
    /// Receiving LLM response (streaming).
    LlmStreaming,
    /// Parsing LLM response.
    LlmParsing,
    /// Classifying SQL safety.
    Classifying,
    /// Executing database query.
    DbExecuting,
    /// Processing results.
    Processing,
}
```

---

## Functional Requirements

### FR-1: Orchestrator Actor

#### FR-1.1: Actor Lifecycle

```rust
pub struct OrchestratorActor {
    /// Database client.
    db: Option<Box<dyn DatabaseClient>>,
    /// LLM client.
    llm: Box<dyn LlmClient>,
    /// Database schema.
    schema: Schema,
    /// Conversation history.
    conversation: Conversation,
    /// Pending request queue.
    queue: VecDeque<PendingRequest>,
    /// Currently processing request.
    current: Option<ActiveRequest>,
    /// Cancellation token for current operation.
    cancel_token: Option<CancellationToken>,
    /// Response channel sender.
    response_tx: mpsc::Sender<OrchestratorResponse>,
}

impl OrchestratorActor {
    /// Runs the actor, processing commands until shutdown.
    pub async fn run(mut self, mut command_rx: mpsc::Receiver<OrchestratorCommand>) {
        loop {
            tokio::select! {
                // Bias toward commands to ensure responsiveness
                biased;

                Some(cmd) = command_rx.recv() => {
                    if self.handle_command(cmd).await.is_break() {
                        break;
                    }
                }

                // Process queue when idle
                _ = self.process_next(), if self.current.is_none() && !self.queue.is_empty() => {}
            }
        }
    }
}
```

#### FR-1.2: Request Queue Management

- Maximum queue depth: 10 requests
- FIFO processing order
- Queue position reported to UI on enqueue
- Position updates sent when queue changes

```rust
struct PendingRequest {
    id: RequestId,
    input: String,
    request_type: RequestType,
    queued_at: Instant,
}

enum RequestType {
    NaturalLanguage,
    RawSql,
    Confirmation,
}
```

#### FR-1.3: Cancellation Handling

- Use `tokio_util::sync::CancellationToken` for cooperative cancellation
- LLM requests: Drop the future (HTTP request may continue server-side)
- DB queries: Cancel via `tokio::select!` with cancel token
- Cleanup partial state on cancellation

```rust
async fn execute_with_cancellation<T, F: Future<Output = T>>(
    &self,
    operation: F,
) -> Result<T, Cancelled> {
    tokio::select! {
        result = operation => Ok(result),
        _ = self.cancel_token.as_ref().unwrap().cancelled() => Err(Cancelled),
    }
}
```

---

### FR-2: TUI Integration

#### FR-2.1: Channel Setup

```rust
pub async fn run_with_orchestrator(
    &mut self,
    connection: Option<&ConnectionConfig>,
    orchestrator: Orchestrator,
) -> Result<()> {
    // Create channels
    let (cmd_tx, cmd_rx) = mpsc::channel::<OrchestratorCommand>(32);
    let (resp_tx, resp_rx) = mpsc::channel::<OrchestratorResponse>(32);

    // Spawn orchestrator actor
    let actor = OrchestratorActor::from_orchestrator(orchestrator, resp_tx);
    let actor_handle = tokio::spawn(actor.run(cmd_rx));

    // Run event loop with channels
    let result = self.run_event_loop(app_state, cmd_tx, resp_rx).await;

    // Cleanup
    let _ = cmd_tx.send(OrchestratorCommand::Shutdown).await;
    let _ = actor_handle.await;

    result
}
```

#### FR-2.2: Non-Blocking Event Loop

```rust
async fn run_event_loop(
    &mut self,
    app_state: &mut App,
    cmd_tx: mpsc::Sender<OrchestratorCommand>,
    mut resp_rx: mpsc::Receiver<OrchestratorResponse>,
) -> Result<()> {
    loop {
        // Always render first
        self.terminal.draw(|f| ui::render(f, app_state))?;

        if !app_state.running {
            break;
        }

        tokio::select! {
            // Terminal events (non-blocking poll)
            event = poll_terminal_event() => {
                if let Some(event) = event? {
                    self.handle_event(event, app_state, &cmd_tx).await;
                }
            }

            // Orchestrator responses
            Some(response) = resp_rx.recv() => {
                self.handle_response(response, app_state);
            }

            // Tick for animations (every 100ms)
            _ = tokio::time::sleep(Duration::from_millis(100)) => {
                app_state.tick();
            }
        }
    }
    Ok(())
}
```

#### FR-2.3: Input Submission

On Enter press:

1. Generate new `RequestId`
2. Add placeholder to chat (shows "Queued" or "Processing")
3. Send `ProcessInput` command to orchestrator
4. Clear input field
5. Input remains enabled for next query

```rust
fn submit_input(&mut self, cmd_tx: &mpsc::Sender<OrchestratorCommand>) {
    let input = self.input.take();
    if input.is_empty() {
        return;
    }

    let id = self.next_request_id();

    // Add user message immediately
    self.add_message(ChatMessage::User(input.clone()));

    // Add pending response placeholder
    self.add_pending_response(id);

    // Send to orchestrator (non-blocking)
    let _ = cmd_tx.try_send(OrchestratorCommand::ProcessInput { id, input });
}
```

---

### FR-3: UI States

#### FR-3.1: Pending Response Placeholder

When a request is submitted, show a placeholder in the chat:

```
┌─────────────────────────────────────────────────────────────────┐
│ You                                                             │
│ Show me all users who signed up this month                      │
├─────────────────────────────────────────────────────────────────┤
│ ⠋ Thinking...                                              2.3s │
└─────────────────────────────────────────────────────────────────┘
```

Placeholder states:

| State         | Display                           |
| ------------- | --------------------------------- |
| Queued        | `◯ Queued (#2 in queue)`          |
| LLM Thinking  | `⠋ Thinking...` (animated)        |
| LLM Streaming | `⠋ Receiving...` + partial text   |
| DB Executing  | `⠋ Executing query...` (animated) |
| Cancelled     | `✗ Cancelled`                     |
| Error         | `✗ Error: <message>`              |

#### FR-3.2: Queue Indicator

When requests are queued, show indicator in status bar:

```
┌─────────────────────────────────────────────────────────────────┐
│ Glance │ mydb@localhost │ ● Connected │ Queue: 2 pending        │
└─────────────────────────────────────────────────────────────────┘
```

#### FR-3.3: Input Field States

| State            | Input Field Behavior                 |
| ---------------- | ------------------------------------ |
| Idle             | Normal input, cursor visible         |
| Processing (1)   | Input enabled, can queue more        |
| Queue Full (10)  | Input disabled, "Queue full" message |
| Awaiting Confirm | Input shows "[y/n]" prompt           |

#### FR-3.4: Elapsed Time Display

- Show elapsed time for operations > 1 second
- Update every 100ms
- Format: `1.2s`, `12.3s`, `1m 23s`

```rust
fn format_elapsed(elapsed: Duration) -> String {
    let secs = elapsed.as_secs_f32();
    if secs < 60.0 {
        format!("{:.1}s", secs)
    } else {
        let mins = secs as u64 / 60;
        let remaining = secs as u64 % 60;
        format!("{}m {}s", mins, remaining)
    }
}
```

---

### FR-4: Cancellation UI

#### FR-4.1: Cancel Current Operation

- **Esc** (when operation in progress): Cancel current operation
- Show "Cancelling..." briefly, then "Cancelled"
- Queued requests remain

#### FR-4.2: Cancel Queued Request

- Navigate to queued item in chat
- Press **x** or **Delete** to cancel
- Item shows "Cancelled" and is removed from queue

#### FR-4.3: Cancel All

- **Ctrl+C** (when operations pending): Cancel all
- Confirmation if queue has multiple items: "Cancel 3 pending requests? [y/n]"
- All items show "Cancelled"

---

### FR-5: Confirmation Flow (Mutations)

#### FR-5.1: Confirmation State

When orchestrator returns `NeedsConfirmation`:

1. Show SQL in chat with warning styling
2. Show confirmation prompt: `Execute this query? [y/n]`
3. Block new input until confirmed/cancelled
4. **y** or **Enter**: Send `ConfirmQuery` command
5. **n** or **Esc**: Send `CancelRequest` command

```
┌─────────────────────────────────────────────────────────────────┐
│ ⚠ Mutating Query                                                │
│ ┌─────────────────────────────────────────────────────────────┐ │
│ │ UPDATE users SET status = 'inactive' WHERE last_login < ... │ │
│ └─────────────────────────────────────────────────────────────┘ │
│ This will modify data. Execute? [y/n]                           │
└─────────────────────────────────────────────────────────────────┘
```

#### FR-5.2: Queue Behavior During Confirmation

- New requests are queued (not processed)
- Queue continues after confirmation resolved
- Cancelling confirmation does not cancel queue

---

### FR-6: Error Handling

#### FR-6.1: Operation Errors

Errors shown inline where result would appear:

```
┌─────────────────────────────────────────────────────────────────┐
│ ✗ Error                                                         │
│ Connection refused: could not connect to database               │
│                                                                 │
│ Query: SELECT * FROM users                                      │
└─────────────────────────────────────────────────────────────────┘
```

#### FR-6.2: Channel Errors

If orchestrator channel closes unexpectedly:

- Show error toast: "Lost connection to orchestrator"
- Attempt reconnection (3 retries)
- If reconnection fails, show modal with options:
  - "Retry connection"
  - "Exit application"

---

## UI Mockups

### Normal Operation (Idle)

```
┌─ Glance ─────────────────────────────────────┬─ Query Log ──────┐
│ mydb@localhost                         ● Conn│                  │
├──────────────────────────────────────────────┤ ┌──────────────┐ │
│                                              │ │ SELECT * ... │ │
│ System                                       │ │ ✓ 12 rows 3ms│ │
│ Welcome to Glance!                           │ └──────────────┘ │
│                                              │ ┌──────────────┐ │
│ You                                          │ │ SELECT COUNT │ │
│ How many users signed up today?              │ │ ✓ 1 row  2ms │ │
│                                              │ └──────────────┘ │
│ Glance                                       │                  │
│ Here are the users who signed up today:      │                  │
│                                              │                  │
│ ┌────┬─────────────┬──────────────────────┐  │                  │
│ │ id │ name        │ email                │  │                  │
│ ├────┼─────────────┼──────────────────────┤  │                  │
│ │ 42 │ Alice Smith │ alice@example.com    │  │                  │
│ │ 43 │ Bob Jones   │ bob@example.com      │  │                  │
│ └────┴─────────────┴──────────────────────┘  │                  │
│ 2 rows returned in 15ms                      │                  │
│                                              │                  │
├──────────────────────────────────────────────┴──────────────────┤
│ > _                                                             │
└─────────────────────────────────────────────────────────────────┘
```

### Processing State (LLM Thinking)

```
┌─ Glance ─────────────────────────────────────┬─ Query Log ──────┐
│ mydb@localhost                         ● Conn│                  │
├──────────────────────────────────────────────┤                  │
│                                              │                  │
│ You                                          │                  │
│ Show me revenue by month for 2024            │                  │
│                                              │                  │
│ ⠹ Thinking...                           3.2s │                  │
│                                              │                  │
│                                              │                  │
│                                              │                  │
│                                              │                  │
│                                              │                  │
│                                              │                  │
│                                              │                  │
│                                              │                  │
│                                              │                  │
├──────────────────────────────────────────────┴──────────────────┤
│ > _                                                             │
└─────────────────────────────────────────────────────────────────┘
```

### Processing with Queue

```
┌─ Glance ─────────────────────────────────────┬─ Query Log ──────┐
│ mydb@localhost                  ● Conn │ ◷ 2 │                  │
├──────────────────────────────────────────────┤                  │
│                                              │                  │
│ You                                          │                  │
│ Show me revenue by month for 2024            │                  │
│                                              │                  │
│ ⠹ Thinking...                           3.2s │                  │
│                                              │                  │
│ You                                          │                  │
│ What about 2023?                             │                  │
│                                              │                  │
│ ◯ Queued (#1)                                │                  │
│                                              │                  │
│ You                                          │                  │
│ And compare to 2022                          │                  │
│                                              │                  │
│ ◯ Queued (#2)                                │                  │
│                                              │                  │
├──────────────────────────────────────────────┴──────────────────┤
│ > _                                                             │
└─────────────────────────────────────────────────────────────────┘
```

### Confirmation Dialog

```
┌─ Glance ─────────────────────────────────────┬─ Query Log ──────┐
│ mydb@localhost                         ● Conn│                  │
├──────────────────────────────────────────────┤                  │
│                                              │                  │
│ You                                          │                  │
│ Delete all inactive users                    │                  │
│                                              │                  │
│ ┌──────────────────────────────────────────┐ │                  │
│ │ ⚠ Destructive Query                      │ │                  │
│ │                                          │ │                  │
│ │ DELETE FROM users                        │ │                  │
│ │ WHERE status = 'inactive'                │ │                  │
│ │ AND last_login < '2024-01-01'            │ │                  │
│ │                                          │ │                  │
│ │ This will permanently delete data.       │ │                  │
│ └──────────────────────────────────────────┘ │                  │
│                                              │                  │
│ Execute this query? [y/n]                    │                  │
│                                              │                  │
├──────────────────────────────────────────────┴──────────────────┤
│ [y] Execute  [n] Cancel                                         │
└─────────────────────────────────────────────────────────────────┘
```

---

## Implementation Plan

### Phase 1: Core Actor Infrastructure

1. Define message types (`OrchestratorCommand`, `OrchestratorResponse`)
2. Create `OrchestratorActor` struct with channel handling
3. Implement basic command processing (no queue yet)
4. Wire up TUI to use channels instead of direct calls

### Phase 2: Request Queue

1. Add `VecDeque<PendingRequest>` to actor
2. Implement queue management (add, remove, position tracking)
3. Add queue status responses
4. Update TUI to show queue indicators

### Phase 3: Cancellation

1. Add `CancellationToken` to actor
2. Implement cancel handlers for each command type
3. Add cancel UI (Esc handling, confirmation for cancel-all)
4. Handle partial results on cancellation

### Phase 4: UI Polish

1. Implement placeholder states in chat
2. Add elapsed time display
3. Add queue indicator to status bar
4. Implement confirmation flow UI

---

## Non-Functional Requirements

### NFR-1: Responsiveness

- UI renders at 60fps regardless of operation state
- Input latency < 16ms at all times
- Spinner animation smooth (no stuttering)

### NFR-2: Reliability

- No message loss between TUI and orchestrator
- Graceful handling of channel closure
- Clean shutdown on exit (no orphaned tasks)

### NFR-3: Memory

- Queue bounded to prevent memory growth
- Completed requests cleaned up promptly
- No leaks from cancelled operations

---

## Testing Strategy

### Unit Tests

- `OrchestratorActor` processes commands correctly
- Queue ordering maintained (FIFO)
- Cancellation token propagates correctly
- Message serialization/deserialization

### Integration Tests

- Full flow: submit → queue → process → complete
- Cancellation mid-operation
- Multiple concurrent requests
- Error propagation

### Manual Testing

- Verify UI responsiveness during slow LLM calls
- Test queue visualization with multiple requests
- Confirm cancellation works at each phase
- Stress test with rapid input submission

---

## Dependencies

- v0.2c should be complete (or merged into this)
- `tokio_util` for `CancellationToken`
- No new external dependencies

---

## Migration Notes

- `Orchestrator` struct becomes internal to actor
- TUI no longer holds direct reference to orchestrator
- Existing tests may need updates for async boundaries

---

## Open Questions

1. **Queue depth**: Is 10 the right maximum? Should it be configurable?
   - _Proposed_: Start with 10, make configurable if users request

2. **Streaming display**: Should LLM streaming tokens appear incrementally?
   - _Proposed_: Yes, implement in Phase 4 or defer to v0.2e

3. **Request priority**: Should some requests (like /clear) skip the queue?
   - _Proposed_: Yes, commands that don't need LLM/DB should be immediate

4. **Persistence**: Should queue survive reconnection?
   - _Proposed_: No, queue is ephemeral. Failed requests can be re-submitted.

---

## Glossary

| Term               | Definition                                                 |
| ------------------ | ---------------------------------------------------------- |
| Actor              | Long-running task that processes messages from a channel   |
| Command Channel    | mpsc channel for sending commands to the orchestrator      |
| Response Channel   | mpsc channel for receiving responses from the orchestrator |
| Request ID         | Unique identifier linking a request to its response        |
| Cancellation Token | Cooperative cancellation mechanism for async operations    |
| Placeholder        | UI element showing pending operation status                |
| Queue Depth        | Number of requests waiting to be processed                 |
