# v0.2e Specification

> Headless Test Mode for AI-Assisted Debugging

**Status**: Planned  
**Target**: Enable LLM agents to run and debug the TUI without terminal access

---

## Overview

v0.2e introduces a headless execution mode that allows the TUI to run without a real terminal. This enables AI agents (and CI pipelines) to:

- Execute scripted event sequences
- Capture rendered screen output as text
- Inspect application state programmatically
- Run deterministic, reproducible test scenarios

The design prioritizes **minimal friction** for LLM interaction: single-command execution with complete feedback in one response.

---

## User Stories

### US-1: AI Agent Debugging

> As an AI agent, I want to run the TUI headlessly so I can debug UI issues without terminal access.

**Acceptance Criteria:**

- Can execute a sequence of events via CLI
- Receive rendered screen as plain text output
- Receive structured app state as JSON
- Single command produces complete feedback (no interactive session)

### US-2: CI Integration Testing

> As a developer, I want to run TUI integration tests in CI where no terminal is available.

**Acceptance Criteria:**

- Headless mode works in non-TTY environments
- Exit code reflects test success/failure
- Can run multiple test scenarios in sequence
- Output suitable for CI logs

### US-3: Reproducible Bug Reports

> As a user, I want to capture a script that reproduces a UI bug so I can share it with developers.

**Acceptance Criteria:**

- Can record a session as an event script
- Script can be replayed headlessly
- Output includes final screen state and any errors

---

## Architecture

### Execution Flow

```
┌─────────────────────────────────────────────────────────────────┐
│                         CLI Entry Point                          │
│                                                                  │
│  glance --headless --events "..." [--output json|text|frames]   │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                      Headless Runner                             │
│  ┌─────────────┐    ┌─────────────┐    ┌─────────────────────┐  │
│  │ Event       │───▶│ App State   │───▶│ TestBackend         │  │
│  │ Parser      │    │             │    │ (in-memory render)  │  │
│  └─────────────┘    └─────────────┘    └─────────────────────┘  │
│         │                                        │               │
│         ▼                                        ▼               │
│  ┌─────────────┐                        ┌─────────────────────┐  │
│  │ Event       │                        │ Screen Buffer       │  │
│  │ Sequence    │                        │ → Text/JSON         │  │
│  └─────────────┘                        └─────────────────────┘  │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                         stdout / file                            │
│  - Rendered screen (text)                                        │
│  - App state (JSON)                                              │
│  - Assertion results                                             │
│  - Exit code: 0 = success, 1 = assertion failed, 2 = error      │
└─────────────────────────────────────────────────────────────────┘
```

### Component Overview

| Component         | Responsibility                            |
| ----------------- | ----------------------------------------- |
| `HeadlessRunner`  | Orchestrates headless execution           |
| `EventParser`     | Parses event DSL into `Event` structs     |
| `ScreenRenderer`  | Converts `TestBackend` buffer to text     |
| `StateSerializer` | Serializes `App` state to JSON            |
| `AssertionEngine` | Evaluates assertions against screen/state |

---

## Functional Requirements

### FR-1: CLI Interface

#### FR-1.1: Headless Flag

```bash
glance --headless [options]
```

When `--headless` is present:

- Use `TestBackend` instead of `CrosstermBackend`
- Do not enter raw mode or alternate screen
- Read events from `--events` or `--script` instead of terminal
- Output to stdout (or file if `--output-file` specified)

#### FR-1.2: Event Input Options

```bash
# Inline events (comma-separated)
glance --headless --events "type:hello,key:enter,wait:100"

# Script file
glance --headless --script events.txt

# Stdin (for piping)
echo "type:hello" | glance --headless --script -
```

#### FR-1.3: Output Format Options

```bash
# Plain text screen (default)
glance --headless --events "..." --output text

# JSON with screen + state
glance --headless --events "..." --output json

# All frames (one per event)
glance --headless --events "..." --output frames

# Write to file instead of stdout
glance --headless --events "..." --output-file result.txt
```

#### FR-1.4: Connection Options

```bash
# Use mock database (no real connection)
glance --headless --mock-db --events "..."

# Connect to real database
glance --headless --connection "postgres://..." --events "..."

# Use connection from config
glance --headless --connection-name mydb --events "..."
```

#### FR-1.5: Screen Size

```bash
# Default: 80x24
glance --headless --events "..."

# Custom size
glance --headless --size 120x40 --events "..."
```

---

### FR-2: Event DSL

#### FR-2.1: Event Types

| Event           | Syntax                      | Description                         |
| --------------- | --------------------------- | ----------------------------------- |
| Key press       | `key:<key>`                 | Single key press                    |
| Type text       | `type:<text>`               | Type a string (multiple key events) |
| Wait            | `wait:<duration>`           | Pause execution                     |
| Assert contains | `assert:contains:<text>`    | Fail if screen doesn't contain text |
| Assert state    | `assert:state:<path>=<val>` | Fail if state doesn't match         |
| Snapshot        | `snapshot:<name>`           | Save current screen to output       |
| Resize          | `resize:<w>x<h>`            | Simulate terminal resize            |

#### FR-2.2: Key Names

```
# Modifiers
ctrl+<key>, alt+<key>, shift+<key>

# Special keys
enter, esc, tab, backspace, delete
up, down, left, right
home, end, pageup, pagedown
f1-f12

# Examples
key:enter
key:ctrl+c
key:ctrl+l
key:esc
key:down
```

#### FR-2.3: Script File Format

```
# comments start with #
# blank lines are ignored

# Type a query
type:show me all users

# Submit
key:enter

# Wait for response (mock LLM is instant, real LLM needs wait)
wait:100ms

# Verify result
assert:contains:users
assert:contains:table_name

# Take a snapshot
snapshot:after_query

# Navigate
key:tab
key:down
key:enter
```

#### FR-2.4: Inline Format

Comma-separated, same syntax without comments:

```bash
--events "type:show tables,key:enter,wait:100,assert:contains:users"
```

---

### FR-3: Output Formats

#### FR-3.1: Text Output (default)

Plain text rendering of the final screen:

```
┌─ Glance ─────────────────────────────────────────┐
│ postgres://localhost/testdb          ● Connected │
├──────────────────────────────────────────────────┤
│ System                                           │
│ Welcome to Glance!                               │
│                                                  │
│ You                                              │
│ show tables                                      │
│                                                  │
│ Glance                                           │
│ Here are the tables in your database:            │
│ ┌────────────┐                                   │
│ │ table_name │                                   │
│ ├────────────┤                                   │
│ │ users      │                                   │
│ │ orders     │                                   │
│ └────────────┘                                   │
├──────────────────────────────────────────────────┤
│ > _                                              │
└──────────────────────────────────────────────────┘

Events: 3 executed
Assertions: 1 passed, 0 failed
```

#### FR-3.2: JSON Output

```json
{
  "screen": "┌─ Glance ─────...",
  "screen_lines": [
    "┌─ Glance ─────────────────────────────────────────┐",
    "│ postgres://localhost/testdb          ● Connected │",
    "..."
  ],
  "state": {
    "running": true,
    "focus": "Input",
    "input_mode": "Insert",
    "input_text": "",
    "message_count": 4,
    "messages": [
      { "type": "System", "content": "Welcome to Glance!" },
      { "type": "User", "content": "show tables" },
      { "type": "Assistant", "content": "Here are the tables..." },
      { "type": "Result", "row_count": 2 }
    ],
    "query_log_count": 1,
    "is_processing": false,
    "is_connected": true
  },
  "events_executed": 3,
  "assertions": {
    "passed": 1,
    "failed": 0,
    "results": [{ "assertion": "contains:users", "passed": true }]
  },
  "snapshots": {
    "after_query": "┌─ Glance ─────..."
  },
  "duration_ms": 42
}
```

#### FR-3.3: Frames Output

One screen per event, separated by markers:

```
=== FRAME 0 (initial) ===
┌─ Glance ─────────────────────────────────────────┐
│ (not connected)                                  │
...

=== FRAME 1 (type:show tables) ===
┌─ Glance ─────────────────────────────────────────┐
│ (not connected)                                  │
...
│ > show tables_                                   │
...

=== FRAME 2 (key:enter) ===
...
```

---

### FR-4: Mock Mode

#### FR-4.1: Mock Database

When `--mock-db` is specified:

- Use in-memory mock database
- Preload with optional seed data
- Deterministic responses

```bash
# Default mock (empty schema)
glance --headless --mock-db --events "..."

# Mock with seed data
glance --headless --mock-db --seed tests/fixtures/seed.sql --events "..."
```

#### FR-4.2: Mock LLM

The existing `MockLlmClient` is used automatically in headless mode unless a real LLM is configured.

```bash
# Uses mock LLM (default in headless)
glance --headless --mock-db --events "..."

# Use real LLM
glance --headless --mock-db --llm anthropic --events "..."
```

---

### FR-5: Assertions

#### FR-5.1: Screen Assertions

```
# Screen contains text (case-insensitive)
assert:contains:users

# Screen contains text (case-sensitive)
assert:contains-exact:SELECT

# Screen matches regex
assert:matches:\d+ rows

# Screen does not contain
assert:not-contains:error
```

#### FR-5.2: State Assertions

```
# Check state value (dot notation for nested)
assert:state:focus=Input
assert:state:is_processing=false
assert:state:message_count>=3
assert:state:messages[0].type=System
```

#### FR-5.3: Assertion Failure Behavior

On assertion failure:

- Continue executing remaining events (unless `--fail-fast`)
- Record failure in output
- Exit with code 1

```bash
# Stop on first failure
glance --headless --fail-fast --events "..."
```

---

### FR-6: Integration with Existing Code

#### FR-6.1: Minimal Changes to Core

The headless runner reuses existing components:

- `App` struct unchanged
- `ui::render()` unchanged
- `Event` enum unchanged
- Only the backend and event source differ

#### FR-6.2: New Module Structure

```
src/
  tui/
    headless/
      mod.rs           # HeadlessRunner
      events.rs        # EventParser, event DSL
      output.rs        # ScreenRenderer, StateSerializer
      assertions.rs    # AssertionEngine
```

#### FR-6.3: CLI Integration

Add to `src/cli.rs`:

```rust
#[derive(Parser)]
pub struct Cli {
    // ... existing fields ...

    /// Run in headless mode (no terminal)
    #[arg(long)]
    pub headless: bool,

    /// Event sequence to execute (headless mode)
    #[arg(long, requires = "headless")]
    pub events: Option<String>,

    /// Event script file (headless mode)
    #[arg(long, requires = "headless")]
    pub script: Option<PathBuf>,

    /// Output format: text, json, frames
    #[arg(long, default_value = "text")]
    pub output: OutputFormat,

    /// Output file (default: stdout)
    #[arg(long)]
    pub output_file: Option<PathBuf>,

    /// Screen size for headless mode
    #[arg(long, default_value = "80x24")]
    pub size: String,

    /// Use mock database
    #[arg(long)]
    pub mock_db: bool,

    /// Seed file for mock database
    #[arg(long, requires = "mock_db")]
    pub seed: Option<PathBuf>,

    /// Stop on first assertion failure
    #[arg(long)]
    pub fail_fast: bool,
}
```

---

## Implementation Plan

### Phase 1: Core Infrastructure

1. Create `src/tui/headless/mod.rs` with `HeadlessRunner`
2. Implement `TestBackend` integration
3. Add `--headless` CLI flag
4. Basic event execution (key presses only)
5. Text output of final screen

### Phase 2: Event DSL

1. Implement `EventParser` for inline events
2. Add script file parsing
3. Implement all event types (key, type, wait, resize)
4. Add duration parsing (`100ms`, `1s`)

### Phase 3: Output Formats

1. Implement JSON output with state serialization
2. Implement frames output
3. Add `--output-file` support
4. Add snapshot events

### Phase 4: Assertions

1. Implement screen assertions (contains, matches)
2. Implement state assertions
3. Add `--fail-fast` flag
4. Proper exit codes

### Phase 5: Mock Integration

1. Wire up `--mock-db` flag
2. Add `--seed` support
3. Ensure mock LLM is default in headless

---

## Non-Functional Requirements

### NFR-1: Performance

- Headless execution should be fast (no artificial delays unless `wait:` specified)
- Suitable for running hundreds of test scenarios in CI

### NFR-2: Determinism

- Same script + same seed = same output
- Mock LLM responses are deterministic
- No timing-dependent behavior (except explicit `wait:`)

### NFR-3: Usability

- Clear error messages for invalid event syntax
- Helpful output on assertion failures (show expected vs actual)
- Exit codes follow conventions (0 = success, 1 = test failure, 2 = error)

---

## Example Usage

### Basic Debugging Session

```bash
# AI agent runs this to see current UI state
glance --headless --mock-db --events "type:show tables,key:enter" --output json
```

### CI Integration Test

```bash
# Run test script, fail if assertions don't pass
glance --headless \
  --connection "$TEST_DB_URL" \
  --script tests/tui/query_flow.txt \
  --fail-fast \
  --output json \
  --output-file test-results.json

# Check exit code
if [ $? -ne 0 ]; then
  echo "TUI test failed"
  cat test-results.json
  exit 1
fi
```

### Reproducing a Bug

```bash
# User provides this script
cat > bug_repro.txt << 'EOF'
type:/sql SELECT * FROM users WHERE
key:enter
wait:100
snapshot:error_state
EOF

# Developer runs it
glance --headless --mock-db --script bug_repro.txt --output frames
```

---

## Testing Strategy

### Unit Tests

- `EventParser` correctly parses all event types
- `ScreenRenderer` produces correct text output
- `AssertionEngine` evaluates assertions correctly
- State serialization is complete and accurate

### Integration Tests

- Full headless execution with mock DB
- All output formats produce valid output
- Assertions work correctly
- Exit codes are correct

### Manual Testing

- Verify output is readable by LLM agents
- Test with real database connection
- Verify CI compatibility (no TTY)

---

## Dependencies

- `ratatui::backend::TestBackend` (already available)
- No new external dependencies

---

## Documentation Updates

### agents.md Updates Required

When implementing v0.2e, the `agents.md` file must be updated with the following instructions for AI agents:

#### Section: TUI Debugging

Add a new section explaining how AI agents should use headless mode:

````markdown
## TUI Debugging with Headless Mode

When debugging TUI issues, use the headless mode to run and inspect the application:

### Basic Usage

```bash
# Run with mock database and see final screen state
glance --headless --mock-db --events "type:show tables,key:enter" --output text

# Get JSON output with full app state
glance --headless --mock-db --events "..." --output json
```
````

### Event Scripting

Create event scripts to reproduce issues:

```
# test_scenario.txt
type:show me all users
key:enter
wait:100ms
assert:contains:users
```

Run with: `glance --headless --mock-db --script test_scenario.txt`

### Best Practices

- **Use `--output json`** for programmatic analysis of state
- **Use `--output frames`** to see state changes step-by-step
- **Add assertions** to verify expected behavior
- **Use `--mock-db`** for deterministic testing
- **Prefer inline events** for quick iteration, scripts for complex scenarios

### Common Debugging Patterns

1. **Reproduce a bug**: Create minimal event sequence that triggers the issue
2. **Verify a fix**: Add assertions to ensure correct behavior
3. **Understand state**: Use JSON output to inspect internal app state
4. **Visual debugging**: Use frames output to see UI changes over time

### Exit Codes

- `0`: Success (all assertions passed)
- `1`: Test failure (assertion failed)
- `2`: Error (invalid syntax, connection failure, etc.)

````

#### Section: Testing Guidelines

Update the testing section to include headless mode:

```markdown
## Testing

### TUI Testing

- Use headless mode for TUI integration tests
- Create event scripts in `tests/tui/` directory
- Use `--fail-fast` in CI to stop on first failure
- Verify both text and JSON output formats work correctly
````

---

## Open Questions

1. **Recording mode**: Should we add `--record` to capture a session as a script?
   - _Proposed_: Defer to future version, focus on playback first

2. **Mouse events**: Should the DSL support mouse events?
   - _Proposed_: Yes, add `mouse:click:<x>,<y>` and `mouse:scroll:<direction>`

3. **Async wait**: Should `wait:` be wall-clock or should we have `wait-for:contains:<text>`?
   - _Proposed_: Add `wait-for:` for polling-based waits (useful with real LLM)

4. **Parallel execution**: Should we support running multiple scripts in parallel?
   - _Proposed_: Defer, can be done with shell parallelism

---

## Glossary

| Term          | Definition                                                   |
| ------------- | ------------------------------------------------------------ |
| Headless Mode | Running without a real terminal, using in-memory rendering   |
| TestBackend   | Ratatui backend that renders to a buffer instead of terminal |
| Event DSL     | Domain-specific language for describing UI events            |
| Assertion     | A check that must pass for the test to succeed               |
| Snapshot      | A captured screen state at a specific point in execution     |
| Mock DB       | In-memory database for deterministic testing                 |
