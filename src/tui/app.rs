//! Application state for the TUI.
//!
//! Contains the main App struct and related types for managing UI state.

use super::history::InputHistory;
use super::widgets::command_palette::CommandPaletteState;
use super::widgets::spinner::Spinner;
use super::widgets::sql_completion::SqlCompletionState;
use crate::config::{ConnectionConfig, UiConfig};
use crate::db::QueryResult;
use crate::db::Schema;
use crate::persistence::SecretStorageStatus;
use std::time::{Duration, Instant};

/// Status of an executed query.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum QueryStatus {
    /// Query executed successfully.
    Success,
    /// Query failed with an error.
    Error,
    /// Query was cancelled before completion.
    Cancelled,
}

/// How a query was initiated.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum QuerySource {
    /// Manually entered via /sql command.
    #[default]
    Manual,
    /// Generated by LLM and confirmed by user.
    Generated,
    /// Generated by LLM and auto-executed (safe query).
    Auto,
}

/// An entry in the query log.
#[derive(Debug, Clone)]
#[allow(dead_code)]
pub struct QueryLogEntry {
    /// The SQL query that was executed.
    pub sql: String,
    /// Whether the query succeeded or failed.
    pub status: QueryStatus,
    /// How long the query took to execute.
    pub execution_time: Duration,
    /// Number of rows returned (for successful queries).
    pub row_count: Option<usize>,
    /// Error message (for failed queries).
    pub error: Option<String>,
    /// When the query was executed.
    pub timestamp: Instant,
    /// How the query was initiated.
    pub source: QuerySource,
    /// The natural language question that triggered this query (for grouping).
    pub nl_question: Option<String>,
    /// Index of the result message in the chat (for navigation).
    pub result_message_index: Option<usize>,
}

impl QueryLogEntry {
    /// Creates a new successful query log entry.
    #[allow(dead_code)]
    pub fn success(sql: String, execution_time: Duration, row_count: usize) -> Self {
        Self {
            sql,
            status: QueryStatus::Success,
            execution_time,
            row_count: Some(row_count),
            error: None,
            timestamp: Instant::now(),
            source: QuerySource::Manual,
            nl_question: None,
            result_message_index: None,
        }
    }

    /// Creates a new successful query log entry with a specific source.
    pub fn success_with_source(
        sql: String,
        execution_time: Duration,
        row_count: usize,
        source: QuerySource,
    ) -> Self {
        Self {
            sql,
            status: QueryStatus::Success,
            execution_time,
            row_count: Some(row_count),
            error: None,
            timestamp: Instant::now(),
            source,
            nl_question: None,
            result_message_index: None,
        }
    }

    /// Creates a new failed query log entry.
    #[allow(dead_code)]
    pub fn error(sql: String, execution_time: Duration, error: String) -> Self {
        Self {
            sql,
            status: QueryStatus::Error,
            execution_time,
            row_count: None,
            error: Some(error),
            timestamp: Instant::now(),
            source: QuerySource::Manual,
            nl_question: None,
            result_message_index: None,
        }
    }

    /// Creates a new failed query log entry with a specific source.
    pub fn error_with_source(
        sql: String,
        execution_time: Duration,
        error: String,
        source: QuerySource,
    ) -> Self {
        Self {
            sql,
            status: QueryStatus::Error,
            execution_time,
            row_count: None,
            error: Some(error),
            timestamp: Instant::now(),
            source,
            nl_question: None,
            result_message_index: None,
        }
    }

    /// Creates a new cancelled query log entry with a specific source.
    pub fn cancelled_with_source(sql: String, source: QuerySource) -> Self {
        Self {
            sql,
            status: QueryStatus::Cancelled,
            execution_time: Duration::ZERO,
            row_count: None,
            error: None,
            timestamp: Instant::now(),
            source,
            nl_question: None,
            result_message_index: None,
        }
    }

    /// Returns a human-readable relative timestamp.
    pub fn relative_time(&self) -> String {
        let elapsed = self.timestamp.elapsed();
        let secs = elapsed.as_secs();

        if secs < 60 {
            "just now".to_string()
        } else if secs < 3600 {
            let mins = secs / 60;
            format!("{}m ago", mins)
        } else if secs < 86400 {
            let hours = secs / 3600;
            format!("{}h ago", hours)
        } else {
            let days = secs / 86400;
            format!("{}d ago", days)
        }
    }

    /// Returns a truncated preview of the SQL (first 30 chars).
    pub fn sql_preview(&self, max_len: usize) -> &str {
        let sql = self.sql.trim();
        if sql.len() <= max_len {
            sql
        } else {
            // Find a safe truncation point (don't split UTF-8)
            let mut end = max_len;
            while end > 0 && !sql.is_char_boundary(end) {
                end -= 1;
            }
            &sql[..end]
        }
    }
}

/// Which panel currently has focus.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum Focus {
    #[default]
    Input,
    Chat,
    Sidebar,
}

/// Input mode for vim-style editing.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum InputMode {
    /// Normal mode: navigation and commands.
    #[default]
    Normal,
    /// Insert mode: text input.
    Insert,
}

impl InputMode {
    /// Returns the display string for the mode indicator.
    pub fn indicator(&self) -> &'static str {
        match self {
            Self::Normal => "-- NORMAL --",
            Self::Insert => "-- INSERT --",
        }
    }
}

impl Focus {
    /// Cycles to the next focus panel.
    pub fn next(self) -> Self {
        match self {
            Self::Input => Self::Chat,
            Self::Chat => Self::Sidebar,
            Self::Sidebar => Self::Input,
        }
    }
}

/// A message in the chat panel.
#[derive(Debug, Clone)]
pub enum ChatMessage {
    /// A message from the user.
    User(String),
    /// A response from the assistant.
    Assistant(String),
    /// A query result to display as a table.
    Result(QueryResult),
    /// An error message.
    Error(String),
    /// A system message (e.g., schema display, help text).
    System(String),
}

#[allow(dead_code)]
impl ChatMessage {
    /// Returns the message type as a string for display purposes.
    pub fn type_label(&self) -> &'static str {
        match self {
            Self::User(_) => "You",
            Self::Assistant(_) => "Glance",
            Self::Result(_) => "Result",
            Self::Error(_) => "Error",
            Self::System(_) => "System",
        }
    }
}

/// Input state for text editing.
#[derive(Debug, Default)]
pub struct InputState {
    /// Current input text.
    pub text: String,
    /// Cursor position (character index).
    pub cursor: usize,
}

impl InputState {
    /// Creates a new empty input state.
    pub fn new() -> Self {
        Self::default()
    }

    /// Inserts a character at the cursor position.
    pub fn insert(&mut self, c: char) {
        self.text.insert(self.cursor, c);
        self.cursor += 1;
    }

    /// Deletes the character before the cursor (backspace).
    pub fn backspace(&mut self) {
        if self.cursor > 0 {
            self.cursor -= 1;
            self.text.remove(self.cursor);
        }
    }

    /// Deletes the character at the cursor (delete key).
    pub fn delete(&mut self) {
        if self.cursor < self.text.len() {
            self.text.remove(self.cursor);
        }
    }

    /// Moves the cursor left.
    pub fn move_left(&mut self) {
        self.cursor = self.cursor.saturating_sub(1);
    }

    /// Moves the cursor right.
    pub fn move_right(&mut self) {
        if self.cursor < self.text.len() {
            self.cursor += 1;
        }
    }

    /// Moves the cursor to the start of the input.
    pub fn move_home(&mut self) {
        self.cursor = 0;
    }

    /// Moves the cursor to the end of the input.
    pub fn move_end(&mut self) {
        self.cursor = self.text.len();
    }

    /// Clears the input and returns the previous text.
    pub fn take(&mut self) -> String {
        self.cursor = 0;
        std::mem::take(&mut self.text)
    }

    /// Returns true if the input is empty.
    pub fn is_empty(&self) -> bool {
        self.text.is_empty()
    }

    /// Clears the input text and resets cursor.
    pub fn clear(&mut self) {
        self.text.clear();
        self.cursor = 0;
    }
}

/// Main application state.
pub struct App {
    /// Whether the application is still running.
    pub running: bool,
    /// Current focus panel.
    pub focus: Focus,
    /// Current input mode (Normal/Insert).
    pub input_mode: InputMode,
    /// Input field state.
    pub input: InputState,
    /// Input history for arrow key navigation.
    pub input_history: InputHistory,
    /// Command palette state.
    pub command_palette: CommandPaletteState,
    /// Chat messages.
    pub messages: Vec<ChatMessage>,
    /// Chat scroll offset (lines from bottom).
    pub chat_scroll: usize,
    /// Whether there are new messages below the current scroll position.
    pub has_new_messages: bool,
    /// Query log entries.
    pub query_log: Vec<QueryLogEntry>,
    /// Currently selected query in sidebar (index into query_log).
    pub selected_query: Option<usize>,
    /// Whether the query detail modal is visible.
    pub show_query_detail: bool,
    /// Database connection info for display.
    pub connection_info: Option<String>,
    /// Pending query awaiting confirmation.
    pub pending_query: Option<PendingQuery>,
    /// Pending plaintext consent: stores the input to replay after user consents.
    pub pending_plaintext_consent: Option<String>,
    /// Whether the application is currently processing (waiting for LLM/DB).
    pub is_processing: bool,
    /// Active spinner for visual feedback during async operations.
    pub spinner: Option<Spinner>,
    /// Last executed SQL query (for copy/re-run features).
    pub last_executed_sql: Option<String>,
    /// Timestamp of last Esc press (for double-Esc detection).
    pub last_esc_time: Option<Instant>,
    /// Flag indicating a cancellation was requested via double-Esc.
    pub cancel_requested: bool,
    /// Toast notification message and expiry time.
    pub toast: Option<(String, Instant)>,
    /// Flag indicating a re-run of the last SQL was requested.
    pub rerun_requested: bool,
    /// Whether the help overlay is visible.
    pub show_help: bool,
    /// Whether to ring the terminal bell on next render (for long query notification).
    pub ring_bell: bool,
    /// Whether the database connection is active/healthy.
    pub is_connected: bool,
    /// Whether vim-style navigation is enabled (toggled via /vim command).
    pub vim_mode_enabled: bool,
    /// Whether to show row numbers in result tables (toggled via /rownumbers command).
    pub show_row_numbers: bool,
    /// Whether to ring bell on long query completion.
    pub bell_on_completion: bool,
    /// Threshold in seconds for long query bell.
    pub bell_threshold_seconds: u64,
    /// Text selection state for copy functionality.
    pub text_selection: Option<TextSelection>,
    /// The area where the chat panel was last rendered (for mouse hit testing).
    pub chat_area: Option<ratatui::layout::Rect>,
    /// The area where the banner was last rendered (for connection status indicator).
    pub banner_area: Option<ratatui::layout::Rect>,
    /// SQL completion state for /sql mode.
    pub sql_completion: SqlCompletionState,
    /// Database schema for completions.
    pub schema: Option<Schema>,
    /// The area where the input bar was last rendered (for popup positioning).
    pub input_area: Option<ratatui::layout::Rect>,
    /// Pending multi-line paste awaiting user confirmation.
    pub pending_paste: Option<PendingPaste>,
    /// Pending requests being tracked for UI display.
    pub pending_requests:
        std::collections::HashMap<crate::tui::orchestrator_actor::RequestId, PendingRequestView>,
    /// Stable ordering of pending requests for rendering.
    pub pending_order: Vec<crate::tui::orchestrator_actor::RequestId>,
    /// Current queue depth from orchestrator.
    pub queue_depth: usize,
    /// Maximum queue depth.
    pub queue_max: usize,
    /// Index of the assistant message currently receiving streamed tokens.
    streaming_assistant_index: Option<usize>,
    /// Index of the result message to highlight and expiry time.
    pub result_highlight: Option<(usize, Instant)>,
    /// Whether the secret storage warning badge has been dismissed.
    pub secret_warning_dismissed: bool,
    /// Current secret storage status (for warning badge).
    pub secret_storage_status: SecretStorageStatus,
    /// Masked input state for sensitive data entry.
    pub masked_input: Option<MaskedInputState>,
    /// History selection popup state.
    pub history_selection: Option<HistorySelectionState>,
}

/// A multi-line paste that may need user confirmation.
#[derive(Debug, Clone)]
#[allow(dead_code)]
pub struct PendingPaste {
    /// The original pasted text.
    pub text: String,
    /// Whether this appears to contain multiple SQL statements.
    pub has_multiple_statements: bool,
}

/// Represents a text selection in the chat panel.
#[derive(Debug, Clone)]
pub struct TextSelection {
    /// Starting position (row, column) in screen coordinates.
    pub start: (u16, u16),
    /// Ending position (row, column) in screen coordinates.
    pub end: (u16, u16),
    /// Whether the selection is currently being dragged.
    pub is_dragging: bool,
}

/// A query that is pending user confirmation.
#[derive(Debug, Clone)]
pub struct PendingQuery {
    /// The SQL to execute.
    pub sql: String,
    /// The safety classification of the query.
    pub classification: crate::safety::ClassificationResult,
}

/// Status of a pending request in the UI.
#[derive(Debug, Clone, PartialEq)]
#[allow(dead_code)] // Variants used in Phase 4 (UI rendering)
pub enum RequestStatus {
    Queued,
    Processing,
    Streaming,
    Cancelled,
    Error(String),
}

/// A pending request being tracked for UI display.
#[derive(Debug, Clone)]
#[allow(dead_code)] // Fields used in Phase 4 (UI rendering)
pub struct PendingRequestView {
    pub id: crate::tui::orchestrator_actor::RequestId,
    pub input: String,
    pub phase: crate::tui::orchestrator_actor::OperationPhase,
    pub queued_at: std::time::Instant,
    pub started_at: Option<std::time::Instant>,
    pub position: Option<usize>,
    pub streaming_content: String,
    pub status: RequestStatus,
}

/// State for masked input mode (for sensitive data like API keys).
#[derive(Debug, Clone)]
#[allow(dead_code)]
pub struct MaskedInputState {
    /// The actual value being entered (hidden from display).
    pub value: String,
    /// Cursor position in the value.
    pub cursor: usize,
    /// The command that triggered masked input (e.g., "/llm key").
    pub command: String,
    /// Prompt to display to the user.
    pub prompt: String,
}

/// State for history selection popup.
#[derive(Debug, Clone)]
pub struct HistorySelectionState {
    /// History entries to display (in reverse chronological order).
    pub entries: Vec<String>,
    /// Currently selected index.
    pub selected: usize,
}

impl App {
    /// Creates a new App instance.
    pub fn new(connection: Option<&ConnectionConfig>, ui_config: &UiConfig) -> Self {
        let connection_info = connection.map(|c| c.display_string_redacted());

        // Add welcome message
        let messages = vec![ChatMessage::System(
            "Welcome to Glance! Ask questions about your database in natural language.".to_string(),
        )];

        Self {
            running: true,
            focus: Focus::default(),
            input_mode: InputMode::Insert, // Start in Insert mode for immediate typing
            input: InputState::new(),
            input_history: InputHistory::new(),
            command_palette: CommandPaletteState::new(),
            messages,
            chat_scroll: 0,
            has_new_messages: false,
            query_log: Vec::new(),
            selected_query: None,
            show_query_detail: false,
            connection_info,
            pending_query: None,
            pending_plaintext_consent: None,
            is_processing: false,
            spinner: None,
            last_executed_sql: None,
            last_esc_time: None,
            cancel_requested: false,
            toast: None,
            rerun_requested: false,
            show_help: false,
            ring_bell: false,
            is_connected: true,
            vim_mode_enabled: ui_config.vim_mode,
            show_row_numbers: ui_config.row_numbers,
            bell_on_completion: ui_config.bell_on_completion,
            bell_threshold_seconds: ui_config.bell_threshold_seconds,
            text_selection: None,
            chat_area: None,
            banner_area: None,
            sql_completion: SqlCompletionState::new(),
            schema: None,
            input_area: None,
            pending_paste: None,
            pending_requests: std::collections::HashMap::new(),
            pending_order: Vec::new(),
            queue_depth: 0,
            queue_max: crate::tui::orchestrator_actor::MAX_QUEUE_DEPTH,
            streaming_assistant_index: None,
            result_highlight: None,
            secret_warning_dismissed: false,
            secret_storage_status: SecretStorageStatus::Secure,
            masked_input: None,
            history_selection: None,
        }
    }

    /// Shows a toast notification that expires after a duration.
    pub fn show_toast(&mut self, message: impl Into<String>) {
        let expiry = Instant::now() + Duration::from_secs(3);
        self.toast = Some((message.into(), expiry));
    }

    /// Dismisses the secret storage warning badge.
    pub fn dismiss_secret_warning(&mut self) {
        self.secret_warning_dismissed = true;
        self.show_toast("Warning dismissed. Check /llm key for details.");
    }

    /// Starts masked input mode for sensitive data entry.
    pub fn start_masked_input(&mut self, command: String, prompt: String) {
        self.masked_input = Some(MaskedInputState {
            value: String::new(),
            cursor: 0,
            command,
            prompt,
        });
        self.input.clear();
    }

    /// Takes the masked input and returns the command with value.
    pub fn take_masked_input(&mut self) -> Option<(String, String)> {
        self.masked_input
            .take()
            .map(|state| (state.command, state.value))
    }

    /// Cancels masked input mode without returning the value.
    pub fn cancel_masked_input(&mut self) {
        self.masked_input = None;
    }

    /// Handles key events in masked input mode.
    /// Returns true if the key was handled.
    pub fn handle_masked_input_key(&mut self, key: crossterm::event::KeyEvent) -> bool {
        use crossterm::event::KeyCode;

        if let Some(state) = &mut self.masked_input {
            match key.code {
                KeyCode::Esc => {
                    self.cancel_masked_input();
                    return true;
                }
                KeyCode::Enter => {
                    // Enter will be handled by submit_input
                    return false;
                }
                KeyCode::Char(c) => {
                    state.value.insert(state.cursor, c);
                    state.cursor += 1;
                    return true;
                }
                KeyCode::Backspace => {
                    if state.cursor > 0 {
                        state.cursor -= 1;
                        state.value.remove(state.cursor);
                    }
                    return true;
                }
                KeyCode::Left => {
                    if state.cursor > 0 {
                        state.cursor -= 1;
                    }
                    return true;
                }
                KeyCode::Right => {
                    if state.cursor < state.value.len() {
                        state.cursor += 1;
                    }
                    return true;
                }
                _ => return true, // Consume all other keys in masked mode
            }
        }
        false
    }

    /// Opens the history selection popup.
    pub fn open_history_selection(&mut self) {
        let entries: Vec<String> = self.input_history.entries().to_vec();
        if !entries.is_empty() {
            self.history_selection = Some(HistorySelectionState {
                entries,
                selected: 0,
            });
        }
    }

    /// Closes the history selection popup.
    pub fn close_history_selection(&mut self) {
        self.history_selection = None;
    }

    /// Moves selection to previous history entry.
    pub fn history_select_previous(&mut self) {
        if let Some(state) = &mut self.history_selection {
            if !state.entries.is_empty() {
                state.selected = state.selected.saturating_sub(1);
            }
        }
    }

    /// Moves selection to next history entry.
    pub fn history_select_next(&mut self) {
        if let Some(state) = &mut self.history_selection {
            if !state.entries.is_empty() {
                state.selected = (state.selected + 1).min(state.entries.len() - 1);
            }
        }
    }

    /// Loads the selected history entry into the input bar and closes the popup.
    /// Returns the selected entry if any.
    pub fn load_selected_history(&mut self) -> Option<String> {
        if let Some(state) = self.history_selection.take() {
            if let Some(entry) = state.entries.get(state.selected).cloned() {
                self.input.text = entry.clone();
                self.input.cursor = entry.len();
                Some(entry)
            } else {
                None
            }
        } else {
            None
        }
    }

    /// Starts the LLM thinking spinner.
    #[allow(dead_code)] // Called from TUI event loop
    pub fn start_thinking(&mut self) {
        self.is_processing = true;
        self.spinner = Some(Spinner::thinking());
    }

    /// Starts the query execution spinner.
    #[allow(dead_code)] // Called from TUI event loop
    pub fn start_executing(&mut self) {
        self.is_processing = true;
        self.spinner = Some(Spinner::executing());
    }

    /// Stops any active spinner.
    #[allow(dead_code)] // Called from TUI event loop
    pub fn stop_spinner(&mut self) {
        self.is_processing = false;
        self.spinner = None;
    }

    /// Requests a terminal bell (for long query notification).
    #[allow(dead_code)] // Called from TUI event loop
    pub fn request_bell(&mut self) {
        self.ring_bell = true;
    }

    /// Takes and clears the bell request.
    pub fn take_bell_request(&mut self) -> bool {
        std::mem::take(&mut self.ring_bell)
    }

    /// Takes and clears the cancellation request.
    #[allow(dead_code)]
    pub fn take_cancel_request(&mut self) -> bool {
        std::mem::take(&mut self.cancel_requested)
    }

    /// Handles Esc key press with double-Esc detection for cancellation.
    /// Returns true if this was a double-Esc (cancellation requested).
    fn handle_esc_for_cancel(&mut self) -> bool {
        let now = Instant::now();
        let double_esc_threshold = Duration::from_millis(500);

        if let Some(last_time) = self.last_esc_time {
            if now.duration_since(last_time) < double_esc_threshold {
                // Double-Esc detected
                self.last_esc_time = None;
                if self.is_processing {
                    self.cancel_requested = true;
                    self.input.clear();
                    self.show_toast("Cancelling operation...");
                    return true;
                }
            }
        }

        self.last_esc_time = Some(now);
        false
    }

    /// Clears expired toast notifications.
    pub fn clear_expired_toast(&mut self) {
        if let Some((_, expiry)) = &self.toast {
            if Instant::now() > *expiry {
                self.toast = None;
            }
        }
    }

    /// Clears expired result highlights.
    pub fn clear_expired_highlight(&mut self) {
        if let Some((_, expiry)) = self.result_highlight {
            if Instant::now() > expiry {
                self.result_highlight = None;
            }
        }
    }

    /// Toggles vim mode on/off.
    pub fn toggle_vim_mode(&mut self) {
        self.vim_mode_enabled = !self.vim_mode_enabled;
        if self.vim_mode_enabled {
            self.show_toast("Vim mode enabled");
            // Start in Insert mode when enabling vim mode
            self.input_mode = InputMode::Insert;
        } else {
            self.show_toast("Vim mode disabled");
            // Reset to Insert mode when disabling
            self.input_mode = InputMode::Insert;
        }
    }

    /// Toggles row numbers in result tables on/off.
    pub fn toggle_row_numbers(&mut self) {
        self.show_row_numbers = !self.show_row_numbers;
        if self.show_row_numbers {
            self.show_toast("Row numbers enabled");
        } else {
            self.show_toast("Row numbers disabled");
        }
    }

    /// Returns true if a confirmation dialog should be shown.
    pub fn has_pending_query(&self) -> bool {
        self.pending_query.is_some()
    }

    /// Sets a pending query that needs confirmation.
    pub fn set_pending_query(
        &mut self,
        sql: String,
        classification: crate::safety::ClassificationResult,
    ) {
        self.pending_query = Some(PendingQuery {
            sql,
            classification,
        });
    }

    /// Clears the pending query.
    pub fn clear_pending_query(&mut self) {
        self.pending_query = None;
    }

    /// Takes the pending query, returning it and clearing the state.
    pub fn take_pending_query(&mut self) -> Option<PendingQuery> {
        self.pending_query.take()
    }

    /// Returns true if a plaintext consent dialog should be shown.
    pub fn has_pending_plaintext_consent(&self) -> bool {
        self.pending_plaintext_consent.is_some()
    }

    /// Sets a pending plaintext consent request with the input to replay.
    pub fn set_pending_plaintext_consent(&mut self, input: String) {
        self.pending_plaintext_consent = Some(input);
    }

    /// Takes the pending plaintext consent, returning it and clearing the state.
    pub fn take_pending_plaintext_consent(&mut self) -> Option<String> {
        self.pending_plaintext_consent.take()
    }

    /// Adds a message to the chat.
    pub fn add_message(&mut self, message: ChatMessage) {
        let index = self.messages.len();

        // If this is a result message, highlight it briefly
        if matches!(message, ChatMessage::Result(_)) {
            let expiry = Instant::now() + Duration::from_millis(200);
            self.result_highlight = Some((index, expiry));
        }

        self.messages.push(message);
        // If user has scrolled up, mark that there are new messages
        if self.chat_scroll > 0 {
            self.has_new_messages = true;
        } else {
            // Auto-scroll to bottom when at bottom
            self.chat_scroll = 0;
        }
    }

    /// Clears all chat messages.
    pub fn clear_messages(&mut self) {
        self.messages.clear();
        self.chat_scroll = 0;
        // Clear per-request tracking
        self.pending_requests.clear();
        self.pending_order.clear();
        self.streaming_assistant_index = None;
        self.result_highlight = None;
    }

    /// Appends a streaming token to the active assistant message.
    /// Note: This is deprecated in favor of per-request streaming.
    pub fn append_streaming_token(&mut self, token: &str) {
        if token.is_empty() {
            return;
        }

        let index = match self.streaming_assistant_index {
            Some(idx) if matches!(self.messages.get(idx), Some(ChatMessage::Assistant(_))) => idx,
            _ => {
                let idx = self.messages.len();
                self.messages.push(ChatMessage::Assistant(String::new()));
                self.streaming_assistant_index = Some(idx);
                idx
            }
        };

        if let Some(ChatMessage::Assistant(content)) = self.messages.get_mut(index) {
            content.push_str(token);
            if self.chat_scroll > 0 {
                self.has_new_messages = true;
            }
        }
    }

    /// Removes any in-progress streaming assistant message.
    /// Note: This is deprecated in favor of per-request tracking.
    pub fn clear_streaming_assistant(&mut self) {
        // No-op for now, streaming is handled per-request
    }

    /// Adds a new pending request to track.
    #[allow(dead_code)] // Used in Phase 3 (mod.rs updates)
    pub fn add_pending_request(
        &mut self,
        id: crate::tui::orchestrator_actor::RequestId,
        input: String,
    ) {
        let view = PendingRequestView {
            id,
            input,
            phase: crate::tui::orchestrator_actor::OperationPhase::Queued,
            queued_at: std::time::Instant::now(),
            started_at: None,
            position: None,
            streaming_content: String::new(),
            status: RequestStatus::Queued,
        };

        self.pending_requests.insert(id, view);
        self.pending_order.push(id);
    }

    /// Updates the phase of a pending request.
    #[allow(dead_code)] // Used in Phase 3 (mod.rs updates)
    pub fn update_request_phase(
        &mut self,
        id: crate::tui::orchestrator_actor::RequestId,
        phase: crate::tui::orchestrator_actor::OperationPhase,
    ) {
        if let Some(req) = self.pending_requests.get_mut(&id) {
            req.phase = phase;
            if req.started_at.is_none()
                && phase != crate::tui::orchestrator_actor::OperationPhase::Queued
            {
                req.started_at = Some(std::time::Instant::now());
            }
        }
    }

    /// Appends streaming content to a specific request.
    #[allow(dead_code)] // Used in Phase 3 (mod.rs updates)
    pub fn append_streaming_to_request(
        &mut self,
        id: crate::tui::orchestrator_actor::RequestId,
        token: &str,
    ) {
        if let Some(req) = self.pending_requests.get_mut(&id) {
            req.streaming_content.push_str(token);
            req.status = RequestStatus::Streaming;
        }
    }

    /// Completes a pending request and removes it from tracking.
    #[allow(dead_code)] // Used in Phase 3 (mod.rs updates)
    pub fn complete_request(&mut self, id: crate::tui::orchestrator_actor::RequestId) {
        self.pending_requests.remove(&id);
        self.pending_order.retain(|rid| *rid != id);
    }

    /// Marks a request as cancelled.
    #[allow(dead_code)] // Used in Phase 3 (mod.rs updates)
    pub fn cancel_request(&mut self, id: crate::tui::orchestrator_actor::RequestId) {
        if let Some(req) = self.pending_requests.get_mut(&id) {
            req.status = RequestStatus::Cancelled;
        }
    }

    /// Updates queue state from orchestrator.
    #[allow(dead_code)] // Used in Phase 3 (mod.rs updates)
    pub fn update_queue_state(
        &mut self,
        depth: usize,
        max: usize,
        positions: Vec<(crate::tui::orchestrator_actor::RequestId, usize)>,
    ) {
        self.queue_depth = depth;
        self.queue_max = max;

        for (id, position) in positions {
            if let Some(req) = self.pending_requests.get_mut(&id) {
                req.position = Some(position);
            }
        }
    }

    /// Returns true if the queue is full.
    #[allow(dead_code)] // Used in Phase 5 (input states)
    pub fn is_queue_full(&self) -> bool {
        self.queue_depth >= self.queue_max
    }

    /// Resets all transient state when switching connections.
    ///
    /// Clears chat messages, query log, input history, scroll positions,
    /// pending confirmations, and other UI state that shouldn't persist
    /// across connection switches.
    pub fn reset_for_connection_switch(&mut self) {
        // Clear chat and conversation state
        self.messages.clear();
        self.chat_scroll = 0;
        self.has_new_messages = false;
        self.pending_requests.clear();
        self.pending_order.clear();

        // Clear query log and selection
        self.query_log.clear();
        self.selected_query = None;
        self.show_query_detail = false;

        // Clear input history
        self.input_history.clear();

        // Clear pending operations and confirmations
        self.pending_query = None;
        self.pending_paste = None;
        self.last_executed_sql = None;

        // Clear transient UI state
        self.spinner = None;
        self.toast = None;
        self.cancel_requested = false;
        self.rerun_requested = false;

        // Keep user preferences and current input text
        // (vim_mode_enabled, show_row_numbers, input, focus, etc.)
    }

    /// Adds a query to the log.
    pub fn add_query_log(&mut self, mut entry: QueryLogEntry) {
        // Check if query was long enough to trigger bell
        if self.bell_on_completion
            && entry.status == QueryStatus::Success
            && entry.execution_time.as_secs() >= self.bell_threshold_seconds
        {
            self.request_bell();
        }

        // Find the index of the last Result message (if any)
        for (idx, msg) in self.messages.iter().enumerate().rev() {
            if matches!(msg, ChatMessage::Result(_)) {
                entry.result_message_index = Some(idx);
                break;
            }
        }

        // Insert at the beginning (most recent first)
        self.query_log.insert(0, entry);
        // Update selection to stay on the same item or select the new one
        if self.selected_query.is_some() {
            self.selected_query = self.selected_query.map(|i| i + 1);
        }
    }

    /// Returns the currently selected query entry, if any.
    pub fn selected_query_entry(&self) -> Option<&QueryLogEntry> {
        self.selected_query.and_then(|i| self.query_log.get(i))
    }

    /// Moves selection up in the query log.
    pub fn select_previous_query(&mut self) {
        if self.query_log.is_empty() {
            return;
        }
        self.selected_query = Some(match self.selected_query {
            None => 0,
            Some(i) => i.saturating_sub(1),
        });
    }

    /// Moves selection down in the query log.
    pub fn select_next_query(&mut self) {
        if self.query_log.is_empty() {
            return;
        }
        let max_index = self.query_log.len().saturating_sub(1);
        self.selected_query = Some(match self.selected_query {
            None => 0,
            Some(i) => i.saturating_add(1).min(max_index),
        });
    }

    /// Opens the query detail modal for the selected query and navigates to result.
    pub fn open_query_detail(&mut self) {
        if let Some(idx) = self.selected_query {
            // Navigate to the result message if available
            if let Some(entry) = self.query_log.get(idx) {
                if let Some(msg_idx) = entry.result_message_index {
                    // Switch focus to chat and scroll to the result
                    self.focus = Focus::Chat;
                    self.scroll_to_message(msg_idx);
                    return;
                }
            }
            // Fall back to showing detail modal if no result message index
            self.show_query_detail = true;
        }
    }

    /// Closes the query detail modal.
    pub fn close_query_detail(&mut self) {
        self.show_query_detail = false;
    }

    /// Scrolls the chat to a specific message index.
    pub fn scroll_to_message(&mut self, message_index: usize) {
        // Calculate approximate scroll position
        // This is a simplified implementation - scroll to make message visible near top
        if message_index < self.messages.len() {
            // Approximate: each message takes ~5 lines on average
            self.chat_scroll = message_index.saturating_mul(5).saturating_sub(5);
            self.has_new_messages = false;
        }
    }

    /// Returns true if the input is in SQL mode (starts with "/sql ").
    pub fn is_sql_mode(&self) -> bool {
        self.input.text.starts_with("/sql ")
    }

    /// Returns the SQL portion of the input (after "/sql ").
    pub fn sql_input(&self) -> &str {
        self.input
            .text
            .strip_prefix("/sql ")
            .unwrap_or(&self.input.text)
    }

    /// Returns the cursor position within the SQL portion.
    pub fn sql_cursor(&self) -> usize {
        if self.is_sql_mode() {
            self.input.cursor.saturating_sub(5) // "/sql " is 5 chars
        } else {
            self.input.cursor
        }
    }

    /// Updates SQL completions based on current input.
    pub fn update_sql_completions(&mut self) {
        if self.is_sql_mode() {
            // Clone the SQL portion to avoid borrow conflicts
            let sql = self.sql_input().to_string();
            let cursor = self.sql_cursor();
            self.sql_completion
                .update(&sql, cursor, self.schema.as_ref());
        } else {
            self.sql_completion.close();
        }
    }

    /// Sets the database schema for SQL completions.
    #[allow(dead_code)]
    pub fn set_schema(&mut self, schema: Schema) {
        self.schema = Some(schema);
    }

    /// Accepts the currently selected SQL completion.
    /// Returns true if a completion was accepted.
    pub fn accept_sql_completion(&mut self, close_popup: bool) -> bool {
        if !self.sql_completion.visible {
            return false;
        }

        if let Some(item) = self.sql_completion.selected_item().cloned() {
            // Record this completion for recency ranking
            self.sql_completion.record_completion(&item.text);

            // Calculate the replacement range
            let filter_len = self.sql_completion.filter.len();
            let sql_cursor = self.sql_cursor();

            // Remove the partial word that was being typed
            let start_pos = 5 + sql_cursor.saturating_sub(filter_len); // 5 for "/sql "
            let end_pos = 5 + sql_cursor;

            // Replace the filter text with the completion
            if start_pos <= self.input.text.len() && end_pos <= self.input.text.len() {
                self.input
                    .text
                    .replace_range(start_pos..end_pos, &item.text);
                self.input.cursor = start_pos + item.text.len();
            }

            if close_popup {
                self.sql_completion.close();
            } else {
                // Update completions for the new input
                self.update_sql_completions();
            }
            return true;
        }
        false
    }

    /// Returns the total number of lines needed to render all messages.
    /// This is used for scroll calculations.
    pub fn total_chat_lines(&self) -> usize {
        self.messages.iter().map(Self::message_line_count).sum()
    }

    /// Estimates the number of lines a message will take to render.
    fn message_line_count(message: &ChatMessage) -> usize {
        match message {
            ChatMessage::User(text)
            | ChatMessage::Assistant(text)
            | ChatMessage::System(text)
            | ChatMessage::Error(text) => {
                // Label line + content lines (rough estimate: 1 line per 80 chars)
                1 + text.len().div_ceil(80).max(1)
            }
            ChatMessage::Result(result) => {
                // Header + column headers + separator + rows + footer
                3 + result.rows.len() + 2
            }
        }
    }

    /// Handles an event and updates application state.
    pub fn handle_event(&mut self, event: super::Event) {
        use super::Event;
        use crossterm::event::KeyCode;

        match event {
            Event::Key(key) => {
                // Dismiss help overlay on any key press
                if self.show_help {
                    self.show_help = false;
                    return;
                }

                match key.code {
                    // Ctrl+C: close palette if visible, copy selection if present, otherwise exit
                    KeyCode::Char('c')
                        if key
                            .modifiers
                            .contains(crossterm::event::KeyModifiers::CONTROL) =>
                    {
                        if self.command_palette.visible {
                            self.command_palette.close();
                            self.input.clear();
                        } else if self.text_selection.is_some() {
                            self.copy_selection();
                        } else {
                            self.running = false;
                        }
                    }
                    KeyCode::Char('q')
                        if key
                            .modifiers
                            .contains(crossterm::event::KeyModifiers::CONTROL) =>
                    {
                        self.running = false;
                    }

                    // Focus switching (but not when SQL completion is visible)
                    KeyCode::Tab if !self.sql_completion.visible => {
                        self.focus = self.focus.next();
                    }

                    // Input handling (when input is focused)
                    _ if self.focus == Focus::Input => {
                        self.handle_input_key(key);
                    }

                    // Chat scrolling (when chat is focused)
                    KeyCode::Up if self.focus == Focus::Chat => {
                        self.chat_scroll = self.chat_scroll.saturating_add(1);
                    }
                    KeyCode::Down if self.focus == Focus::Chat => {
                        self.chat_scroll = self.chat_scroll.saturating_sub(1);
                        if self.chat_scroll == 0 {
                            self.has_new_messages = false;
                        }
                    }
                    KeyCode::PageUp if self.focus == Focus::Chat => {
                        self.chat_scroll = self.chat_scroll.saturating_add(10);
                    }
                    KeyCode::PageDown if self.focus == Focus::Chat => {
                        self.chat_scroll = self.chat_scroll.saturating_sub(10);
                        if self.chat_scroll == 0 {
                            self.has_new_messages = false;
                        }
                    }
                    KeyCode::Home if self.focus == Focus::Chat => {
                        self.chat_scroll = usize::MAX; // Will be clamped during render
                    }
                    KeyCode::End if self.focus == Focus::Chat => {
                        self.chat_scroll = 0;
                        self.has_new_messages = false;
                    }

                    // Modal handling (Esc closes modal)
                    KeyCode::Esc if self.show_query_detail => {
                        self.close_query_detail();
                    }

                    // Sidebar navigation (when sidebar is focused)
                    KeyCode::Up if self.focus == Focus::Sidebar => {
                        self.select_previous_query();
                    }
                    KeyCode::Down if self.focus == Focus::Sidebar => {
                        self.select_next_query();
                    }
                    KeyCode::Enter if self.focus == Focus::Sidebar => {
                        self.open_query_detail();
                    }

                    _ => {}
                }
            }
            Event::Mouse(mouse) => {
                self.handle_mouse_event(mouse);
            }
            Event::Resize(width, height) => {
                // Terminal resize: clamp scroll position to valid range
                // The actual re-render is handled automatically by ratatui
                self.handle_resize(width, height);
            }
            Event::Tick => {
                // Periodic tick for animations/updates (not used yet)
            }
            Event::Paste(text) => {
                self.handle_paste(text);
            }
        }
    }

    /// Handles pasted text with multi-line detection per FR-7.3.
    fn handle_paste(&mut self, text: String) {
        if text.is_empty() {
            return;
        }

        // Check if paste contains newlines
        if text.contains('\n') {
            // Check if this looks like multiple SQL statements
            let has_multiple_statements = self.detect_multiple_sql_statements(&text);

            if has_multiple_statements {
                // Store pending paste for user confirmation
                self.pending_paste = Some(PendingPaste {
                    text: text.clone(),
                    has_multiple_statements: true,
                });
                self.show_toast("Multi-statement paste detected. Press 'y' to merge, 'n' to keep as-is, Esc to cancel");
            } else {
                // Single SQL statement: convert newlines to spaces
                let normalized = text.replace('\n', " ").replace("  ", " ");
                self.input.text.push_str(&normalized);
                self.input.cursor = self.input.text.len();
                self.update_sql_completions();
            }
        } else {
            // No newlines, just insert the text
            self.input.text.push_str(&text);
            self.input.cursor = self.input.text.len();
            self.update_sql_completions();
        }
    }

    /// Detects if pasted text contains multiple SQL statements.
    fn detect_multiple_sql_statements(&self, text: &str) -> bool {
        // Count semicolons that aren't inside strings (simple heuristic)
        let mut semicolon_count = 0;
        let mut in_string = false;
        let mut prev_char = ' ';

        for c in text.chars() {
            match c {
                '\'' if prev_char != '\\' => in_string = !in_string,
                ';' if !in_string => semicolon_count += 1,
                _ => {}
            }
            prev_char = c;
        }

        // Multiple statements if more than one semicolon, or one semicolon not at the end
        semicolon_count > 1 || (semicolon_count == 1 && !text.trim().ends_with(';'))
    }

    /// Handles pending paste confirmation (y/n).
    pub fn handle_paste_confirmation(&mut self, accept: bool) -> bool {
        if let Some(pending) = self.pending_paste.take() {
            if accept {
                // Merge: convert newlines to spaces
                let normalized = pending.text.replace('\n', " ").replace("  ", " ");
                self.input.text.push_str(&normalized);
            } else {
                // Keep as-is: preserve newlines (user can review)
                self.input.text.push_str(&pending.text);
            }
            self.input.cursor = self.input.text.len();
            self.update_sql_completions();
            true
        } else {
            false
        }
    }

    /// Returns true if there's a pending paste awaiting confirmation.
    pub fn has_pending_paste(&self) -> bool {
        self.pending_paste.is_some()
    }

    /// Cancels any pending paste.
    pub fn cancel_pending_paste(&mut self) {
        self.pending_paste = None;
    }

    /// Handles mouse events for text selection.
    fn handle_mouse_event(&mut self, mouse: crossterm::event::MouseEvent) {
        use crossterm::event::{MouseButton, MouseEventKind};

        match mouse.kind {
            MouseEventKind::Down(MouseButton::Left) => {
                // Check if click is on the "New messages" banner
                if let Some(banner) = self.banner_area {
                    if mouse.column >= banner.x
                        && mouse.column < banner.x + banner.width
                        && mouse.row >= banner.y
                        && mouse.row < banner.y + banner.height
                    {
                        // Jump to bottom and clear new messages flag
                        self.chat_scroll = 0;
                        self.has_new_messages = false;
                        return;
                    }
                }

                // Check if click is within chat area
                if let Some(area) = self.chat_area {
                    if mouse.column >= area.x
                        && mouse.column < area.x + area.width
                        && mouse.row >= area.y
                        && mouse.row < area.y + area.height
                    {
                        // Start a new selection
                        self.text_selection = Some(TextSelection {
                            start: (mouse.row, mouse.column),
                            end: (mouse.row, mouse.column),
                            is_dragging: true,
                        });
                    } else {
                        // Click outside chat area clears selection
                        self.text_selection = None;
                    }
                }
            }
            MouseEventKind::Drag(MouseButton::Left) => {
                // Update selection end point while dragging
                if let Some(ref mut selection) = self.text_selection {
                    if selection.is_dragging {
                        selection.end = (mouse.row, mouse.column);
                    }
                }
            }
            MouseEventKind::Up(MouseButton::Left) => {
                // End dragging
                if let Some(ref mut selection) = self.text_selection {
                    selection.is_dragging = false;
                    // If start and end are the same, clear selection (it was just a click)
                    if selection.start == selection.end {
                        self.text_selection = None;
                    }
                }
            }
            _ => {}
        }
    }

    /// Handles terminal resize by clamping scroll positions.
    fn handle_resize(&mut self, _width: u16, _height: u16) {
        // Clamp chat scroll to valid range based on content
        let max_scroll = self.total_chat_lines().saturating_sub(1);
        self.chat_scroll = self.chat_scroll.min(max_scroll);

        // Clamp sidebar selection to valid range
        if let Some(selected) = self.selected_query {
            if selected >= self.query_log.len() {
                self.selected_query = if self.query_log.is_empty() {
                    None
                } else {
                    Some(self.query_log.len() - 1)
                };
            }
        }
    }

    /// Handles key events when input is focused.
    fn handle_input_key(&mut self, key: crossterm::event::KeyEvent) {
        // When vim mode is disabled, always use standard input handling
        if !self.vim_mode_enabled {
            self.handle_standard_input_key(key);
            return;
        }

        // Vim mode enabled: use Normal/Insert mode switching
        match self.input_mode {
            InputMode::Normal => self.handle_normal_mode_key(key),
            InputMode::Insert => self.handle_insert_mode_key(key),
        }
    }

    /// Handles command palette input. Returns true if event was consumed.
    fn handle_command_palette_key(&mut self, key: crossterm::event::KeyEvent) -> bool {
        use crossterm::event::KeyCode;

        if !self.command_palette.visible {
            return false;
        }

        match key.code {
            KeyCode::Esc => {
                self.command_palette.close();
            }
            KeyCode::Up => {
                self.command_palette.select_previous();
            }
            KeyCode::Down => {
                self.command_palette.select_next();
            }
            KeyCode::Tab => {
                if let Some(cmd) = self.command_palette.selected_command() {
                    self.input.text = format!("/{} ", cmd.name);
                    self.input.cursor = self.input.text.len();
                }
                self.command_palette.close();
            }
            KeyCode::Enter => {
                if let Some(cmd) = self.command_palette.selected_command() {
                    self.input.text = format!("/{} ", cmd.name);
                    self.input.cursor = self.input.text.len();
                }
                self.command_palette.close_and_submit();
            }
            KeyCode::Backspace => {
                if self.input.text.len() > 1 {
                    self.input.backspace();
                    let filter = self.input.text.strip_prefix('/').unwrap_or("");
                    self.command_palette.set_filter(filter);
                } else {
                    self.input.backspace();
                    self.command_palette.close();
                }
            }
            KeyCode::Char(c) => {
                self.input.insert(c);
                // If space is typed after a valid command name, close the palette
                if c == ' ' {
                    let filter = self.input.text.strip_prefix('/').unwrap_or("");
                    let cmd_name = filter.trim_end();
                    // Check if the text before space matches a command name exactly
                    let is_complete_command = super::widgets::command_palette::COMMANDS
                        .iter()
                        .any(|cmd| cmd.name.eq_ignore_ascii_case(cmd_name));
                    if is_complete_command {
                        self.command_palette.close();
                        // Trigger SQL completions if we just completed "/sql "
                        self.update_sql_completions();
                        return true;
                    }
                }
                let filter = self.input.text.strip_prefix('/').unwrap_or("");
                self.command_palette.set_filter(filter);
            }
            _ => {}
        }
        true
    }

    /// Handles SQL completion input. Returns true if event was consumed.
    fn handle_sql_completion_key(&mut self, key: crossterm::event::KeyEvent) -> bool {
        use crossterm::event::KeyCode;

        if !self.sql_completion.visible {
            // Ctrl+Space forces completion popup open
            if key.code == KeyCode::Char(' ')
                && key
                    .modifiers
                    .contains(crossterm::event::KeyModifiers::CONTROL)
                && self.is_sql_mode()
            {
                self.sql_completion.force_open();
                self.update_sql_completions();
                return true;
            }
            return false;
        }

        match key.code {
            KeyCode::Esc => {
                self.sql_completion.close();
                true
            }
            KeyCode::Up => {
                self.sql_completion.select_previous();
                true
            }
            KeyCode::Down => {
                self.sql_completion.select_next();
                true
            }
            KeyCode::Tab => {
                // Accept completion and close popup
                self.accept_sql_completion(true);
                true
            }
            _ => false, // Let other keys (including Enter) pass through
        }
    }

    /// Handles history selection input. Returns true if event was consumed.
    fn handle_history_selection_key(&mut self, key: crossterm::event::KeyEvent) -> bool {
        use crossterm::event::KeyCode;

        if self.history_selection.is_none() {
            // Ctrl+R opens history selection
            if key.code == KeyCode::Char('r')
                && key
                    .modifiers
                    .contains(crossterm::event::KeyModifiers::CONTROL)
            {
                self.open_history_selection();
                return true;
            }
            return false;
        }

        match key.code {
            KeyCode::Esc => {
                self.close_history_selection();
                true
            }
            KeyCode::Up => {
                self.history_select_previous();
                true
            }
            KeyCode::Down => {
                self.history_select_next();
                true
            }
            KeyCode::Enter => {
                self.load_selected_history();
                true
            }
            _ => true, // Consume all other keys when popup is visible
        }
    }

    /// Handles key events in standard mode (vim mode disabled).
    fn handle_standard_input_key(&mut self, key: crossterm::event::KeyEvent) {
        use crossterm::event::KeyCode;

        // Handle masked input mode first
        if self.handle_masked_input_key(key) {
            return;
        }

        // Handle pending paste confirmation first
        if self.has_pending_paste() {
            match key.code {
                KeyCode::Char('y') | KeyCode::Char('Y') => {
                    self.handle_paste_confirmation(true);
                    return;
                }
                KeyCode::Char('n') | KeyCode::Char('N') => {
                    self.handle_paste_confirmation(false);
                    return;
                }
                KeyCode::Esc => {
                    self.cancel_pending_paste();
                    return;
                }
                _ => return, // Ignore other keys during paste confirmation
            }
        }

        // Handle command palette if visible
        if self.handle_command_palette_key(key) {
            return;
        }

        // Handle SQL completion if visible
        if self.handle_sql_completion_key(key) {
            return;
        }

        // Handle history selection if visible or Ctrl+R
        if self.handle_history_selection_key(key) {
            return;
        }

        match key.code {
            // Esc: check for double-Esc cancellation first, then close overlays or clear input
            KeyCode::Esc => {
                // Double-Esc cancellation takes priority
                if self.handle_esc_for_cancel() {
                    return;
                }
                // Single Esc: close SQL completion or clear input
                if self.sql_completion.visible {
                    self.sql_completion.close();
                } else {
                    self.input.clear();
                }
            }
            // Clear input with Ctrl+U
            KeyCode::Char('u')
                if key
                    .modifiers
                    .contains(crossterm::event::KeyModifiers::CONTROL) =>
            {
                self.input.clear();
                self.sql_completion.close();
            }
            // History navigation (only when SQL completion not visible)
            KeyCode::Up => {
                if let Some(entry) = self.input_history.previous(&self.input.text) {
                    self.input.text = entry.to_string();
                    self.input.cursor = self.input.text.len();
                    self.update_sql_completions();
                }
            }
            KeyCode::Down => {
                if let Some(entry) = self.input_history.next() {
                    self.input.text = entry.to_string();
                    self.input.cursor = self.input.text.len();
                    self.update_sql_completions();
                }
            }
            // Text input
            KeyCode::Char(c) => {
                if c == '/' && self.input.cursor == 0 {
                    self.input.insert(c);
                    self.command_palette.open();
                } else {
                    self.input.insert(c);
                    self.update_sql_completions();
                }
            }
            KeyCode::Backspace => {
                self.input.backspace();
                self.update_sql_completions();
            }
            KeyCode::Delete => {
                self.input.delete();
                self.update_sql_completions();
            }
            KeyCode::Left => {
                self.input.move_left();
                self.update_sql_completions();
            }
            KeyCode::Right => {
                self.input.move_right();
                self.update_sql_completions();
            }
            KeyCode::Home => {
                self.input.move_home();
                self.update_sql_completions();
            }
            KeyCode::End => {
                self.input.move_end();
                self.update_sql_completions();
            }
            KeyCode::Enter => {
                // Enter is handled by the main event loop for submission
            }
            _ => {}
        }
    }

    /// Handles key events in Normal mode.
    fn handle_normal_mode_key(&mut self, key: crossterm::event::KeyEvent) {
        use crossterm::event::KeyCode;

        match key.code {
            // Enter Insert mode
            KeyCode::Char('i') => {
                self.input_mode = InputMode::Insert;
            }
            // Enter Insert mode at end of line
            KeyCode::Char('a') => {
                self.input_mode = InputMode::Insert;
                self.input.move_end();
            }
            // Enter Insert mode at start of line
            KeyCode::Char('I') => {
                self.input_mode = InputMode::Insert;
                self.input.move_home();
            }
            // Enter Insert mode at end of line (append)
            KeyCode::Char('A') => {
                self.input_mode = InputMode::Insert;
                self.input.move_end();
            }
            // Navigation in Normal mode
            KeyCode::Char('h') | KeyCode::Left => {
                self.input.move_left();
            }
            KeyCode::Char('l') | KeyCode::Right => {
                self.input.move_right();
            }
            KeyCode::Char('0') | KeyCode::Home => {
                self.input.move_home();
            }
            KeyCode::Char('$') | KeyCode::End => {
                self.input.move_end();
            }
            // Delete character under cursor
            KeyCode::Char('x') => {
                self.input.delete();
            }
            // Copy last SQL to clipboard
            KeyCode::Char('y') => {
                self.copy_last_sql();
            }
            // Edit last SQL - load into input
            KeyCode::Char('e') => {
                self.edit_last_sql();
            }
            // Re-run last SQL
            KeyCode::Char('r') => {
                self.request_rerun();
            }
            // Toggle help overlay
            KeyCode::Char('?') => {
                self.show_help = !self.show_help;
            }
            // Dismiss secret storage warning badge
            KeyCode::Char('w') => {
                if !self.secret_warning_dismissed
                    && self.secret_storage_status == SecretStorageStatus::PlaintextConsented
                {
                    self.dismiss_secret_warning();
                }
            }
            // Vim-style scrolling
            KeyCode::Char('j') => {
                self.chat_scroll = self.chat_scroll.saturating_sub(1);
                if self.chat_scroll == 0 {
                    self.has_new_messages = false;
                }
            }
            KeyCode::Char('k') => {
                self.chat_scroll = self.chat_scroll.saturating_add(1);
            }
            KeyCode::Char('g') => {
                // Go to top (oldest messages)
                self.chat_scroll = self.total_chat_lines();
            }
            KeyCode::Char('G') => {
                // Go to bottom (newest messages)
                self.chat_scroll = 0;
                self.has_new_messages = false;
            }
            KeyCode::Char('d')
                if key
                    .modifiers
                    .contains(crossterm::event::KeyModifiers::CONTROL) =>
            {
                // Half page down
                self.chat_scroll = self.chat_scroll.saturating_sub(10);
            }
            KeyCode::Char('u')
                if key
                    .modifiers
                    .contains(crossterm::event::KeyModifiers::CONTROL) =>
            {
                // Half page up
                self.chat_scroll = self.chat_scroll.saturating_add(10);
            }
            _ => {}
        }
    }

    /// Copies the last executed SQL to the clipboard.
    fn copy_last_sql(&mut self) {
        if let Some(sql) = &self.last_executed_sql {
            match super::clipboard::copy(sql) {
                Ok(()) => {
                    self.show_toast("Copied SQL to clipboard");
                }
                Err(e) => {
                    self.show_toast(format!("Failed to copy: {}", e));
                }
            }
        } else {
            self.show_toast("No SQL to copy");
        }
    }

    /// Copies the selected text to the clipboard.
    fn copy_selection(&mut self) {
        if let Some(ref selection) = self.text_selection {
            // Get the selected text from the rendered chat content
            if let Some(text) = self.get_selected_text(selection) {
                if text.is_empty() {
                    self.show_toast("No text selected");
                } else {
                    match super::clipboard::copy(&text) {
                        Ok(()) => {
                            self.show_toast("Copied to clipboard");
                        }
                        Err(e) => {
                            self.show_toast(format!("Failed to copy: {}", e));
                        }
                    }
                }
            }
            // Clear selection after copy
            self.text_selection = None;
        }
    }

    /// Extracts the selected text from the chat panel based on screen coordinates.
    fn get_selected_text(&self, selection: &TextSelection) -> Option<String> {
        // Get the chat area bounds
        let area = self.chat_area?;

        // Normalize selection (start should be before end)
        let (start, end) = if selection.start.0 < selection.end.0
            || (selection.start.0 == selection.end.0 && selection.start.1 <= selection.end.1)
        {
            (selection.start, selection.end)
        } else {
            (selection.end, selection.start)
        };

        // Convert screen coordinates to content coordinates (relative to chat area)
        let start_row = start.0.saturating_sub(area.y) as usize;
        let start_col = start.1.saturating_sub(area.x) as usize;
        let end_row = end.0.saturating_sub(area.y) as usize;
        let end_col = end.1.saturating_sub(area.x) as usize;

        // Render messages to get the actual text content
        let available_width = area.width.saturating_sub(2) as usize; // Account for borders
        let lines = self.render_chat_lines(available_width);

        // Calculate visible range based on scroll
        let available_height = area.height.saturating_sub(2) as usize; // Account for borders
        let total_lines = lines.len();
        let max_scroll = total_lines.saturating_sub(available_height);
        let clamped_scroll = self.chat_scroll.min(max_scroll);
        let visible_start = max_scroll.saturating_sub(clamped_scroll);

        // Extract text from the visible lines
        let mut selected_text = String::new();
        for (i, line) in lines
            .iter()
            .skip(visible_start)
            .take(available_height)
            .enumerate()
        {
            // Adjust for border (1 row offset)
            let line_row = i + 1;

            if line_row >= start_row && line_row <= end_row {
                // This line is part of the selection
                let line_start = if line_row == start_row {
                    start_col.saturating_sub(1) // Account for border
                } else {
                    0
                };
                let line_end = if line_row == end_row {
                    end_col.saturating_sub(1) // Account for border
                } else {
                    line.len()
                };

                if line_start < line.len() {
                    let end_idx = line_end.min(line.len());
                    if line_start < end_idx {
                        selected_text.push_str(&line[line_start..end_idx]);
                    }
                }

                // Add newline between lines (but not after the last line)
                if line_row < end_row {
                    selected_text.push('\n');
                }
            }
        }

        Some(selected_text)
    }

    /// Renders chat messages to plain text lines for selection purposes.
    fn render_chat_lines(&self, _available_width: usize) -> Vec<String> {
        let mut lines = Vec::new();

        for message in &self.messages {
            if !lines.is_empty() {
                lines.push(String::new());
            }

            match message {
                ChatMessage::User(text) => {
                    lines.push("You:".to_string());
                    for line in text.lines() {
                        lines.push(format!("  {}", line));
                    }
                }
                ChatMessage::Assistant(text) => {
                    lines.push("Glance:".to_string());
                    for line in text.lines() {
                        lines.push(format!("  {}", line));
                    }
                }
                ChatMessage::Result(result) => {
                    // Simplified: just show column names and row data
                    let header: Vec<_> = result.columns.iter().map(|c| c.name.as_str()).collect();
                    lines.push(header.join("\t"));
                    for row in &result.rows {
                        let row_text: Vec<_> = row.iter().map(|v| v.to_string()).collect();
                        lines.push(row_text.join("\t"));
                    }
                }
                ChatMessage::Error(text) => {
                    lines.push("Error:".to_string());
                    for line in text.lines() {
                        lines.push(format!("  {}", line));
                    }
                }
                ChatMessage::System(text) => {
                    for line in text.lines() {
                        lines.push(line.to_string());
                    }
                }
            }
        }

        lines
    }

    /// Loads the last executed SQL into the input field for editing.
    fn edit_last_sql(&mut self) {
        if let Some(sql) = &self.last_executed_sql.clone() {
            let prefixed = format!("/sql {}", sql);
            self.input.text = prefixed.clone();
            self.input.cursor = prefixed.len();
            self.input_mode = InputMode::Insert;
            self.show_toast("Loaded last SQL for editing");
        } else {
            self.show_toast("No SQL to edit");
        }
    }

    /// Returns the last SQL for re-execution, if any.
    /// The caller should handle actually executing the query.
    #[allow(dead_code)] // Will be used by TUI event loop
    pub fn get_rerun_sql(&self) -> Option<String> {
        self.last_executed_sql.clone()
    }

    /// Requests a re-run of the last SQL query.
    fn request_rerun(&mut self) {
        if self.last_executed_sql.is_some() {
            self.rerun_requested = true;
            self.show_toast("Re-running last SQL...");
        } else {
            self.show_toast("No SQL to re-run");
        }
    }

    /// Takes and clears the rerun request, returning the SQL if requested.
    pub fn take_rerun_request(&mut self) -> Option<String> {
        if self.rerun_requested {
            self.rerun_requested = false;
            self.last_executed_sql.clone()
        } else {
            None
        }
    }

    /// Handles key events in Insert mode.
    fn handle_insert_mode_key(&mut self, key: crossterm::event::KeyEvent) {
        use crossterm::event::KeyCode;

        // Handle pending paste confirmation first
        if self.has_pending_paste() {
            match key.code {
                KeyCode::Char('y') | KeyCode::Char('Y') => {
                    self.handle_paste_confirmation(true);
                    return;
                }
                KeyCode::Char('n') | KeyCode::Char('N') => {
                    self.handle_paste_confirmation(false);
                    return;
                }
                KeyCode::Esc => {
                    self.cancel_pending_paste();
                    return;
                }
                _ => return, // Ignore other keys during paste confirmation
            }
        }

        // Handle command palette if visible (uses shared handler)
        if self.handle_command_palette_key(key) {
            return;
        }

        // Handle SQL completion if visible
        if self.handle_sql_completion_key(key) {
            return;
        }

        match key.code {
            // Esc: check for double-Esc cancellation first, then close overlays or switch mode
            KeyCode::Esc => {
                // Double-Esc cancellation takes priority
                if self.handle_esc_for_cancel() {
                    return;
                }
                // Single Esc: close SQL completion or switch to Normal mode
                if self.sql_completion.visible {
                    self.sql_completion.close();
                } else {
                    self.input_mode = InputMode::Normal;
                }
            }
            // Clear input with Ctrl+U
            KeyCode::Char('u')
                if key
                    .modifiers
                    .contains(crossterm::event::KeyModifiers::CONTROL) =>
            {
                self.input.clear();
                self.sql_completion.close();
            }
            // History navigation
            KeyCode::Up => {
                if let Some(entry) = self.input_history.previous(&self.input.text) {
                    self.input.text = entry.to_string();
                    self.input.cursor = self.input.text.len();
                    self.update_sql_completions();
                }
            }
            KeyCode::Down => {
                if let Some(entry) = self.input_history.next() {
                    self.input.text = entry.to_string();
                    self.input.cursor = self.input.text.len();
                    self.update_sql_completions();
                }
            }
            // Text input
            KeyCode::Char(c) => {
                // Check if this triggers command palette
                if c == '/' && self.input.cursor == 0 {
                    self.input.insert(c);
                    self.command_palette.open();
                } else {
                    self.input.insert(c);
                    self.update_sql_completions();
                }
            }
            KeyCode::Backspace => {
                self.input.backspace();
                self.update_sql_completions();
            }
            KeyCode::Delete => {
                self.input.delete();
                self.update_sql_completions();
            }
            KeyCode::Left => {
                self.input.move_left();
                self.update_sql_completions();
            }
            KeyCode::Right => {
                self.input.move_right();
                self.update_sql_completions();
            }
            KeyCode::Home => {
                self.input.move_home();
                self.update_sql_completions();
            }
            KeyCode::End => {
                self.input.move_end();
                self.update_sql_completions();
            }
            KeyCode::Enter => {
                // Enter is handled by the main event loop for submission
            }
            _ => {}
        }
    }

    /// Submits the current input for processing.
    pub fn submit_input(&mut self) -> Option<String> {
        // If in masked input mode, construct the command with the masked value
        if let Some((command, value)) = self.take_masked_input() {
            return Some(format!("{} {}", command, value));
        }

        if self.input.is_empty() {
            None
        } else {
            let text = self.input.take();
            // Add to history and reset position
            self.input_history.push(text.clone());
            self.input_history.reset_position();
            Some(text)
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::config::UiConfig;

    #[test]
    fn test_input_insert() {
        let mut input = InputState::new();
        input.insert('h');
        input.insert('i');
        assert_eq!(input.text, "hi");
        assert_eq!(input.cursor, 2);
    }

    #[test]
    fn test_input_backspace() {
        let mut input = InputState::new();
        input.text = "hello".to_string();
        input.cursor = 5;
        input.backspace();
        assert_eq!(input.text, "hell");
        assert_eq!(input.cursor, 4);
    }

    #[test]
    fn test_input_backspace_at_start() {
        let mut input = InputState::new();
        input.text = "hello".to_string();
        input.cursor = 0;
        input.backspace();
        assert_eq!(input.text, "hello");
        assert_eq!(input.cursor, 0);
    }

    #[test]
    fn test_input_delete() {
        let mut input = InputState::new();
        input.text = "hello".to_string();
        input.cursor = 0;
        input.delete();
        assert_eq!(input.text, "ello");
        assert_eq!(input.cursor, 0);
    }

    #[test]
    fn test_input_cursor_movement() {
        let mut input = InputState::new();
        input.text = "hello".to_string();
        input.cursor = 2;

        input.move_left();
        assert_eq!(input.cursor, 1);

        input.move_right();
        assert_eq!(input.cursor, 2);

        input.move_home();
        assert_eq!(input.cursor, 0);

        input.move_end();
        assert_eq!(input.cursor, 5);
    }

    #[test]
    fn test_input_take() {
        let mut input = InputState::new();
        input.text = "hello".to_string();
        input.cursor = 3;

        let text = input.take();
        assert_eq!(text, "hello");
        assert!(input.text.is_empty());
        assert_eq!(input.cursor, 0);
    }

    #[test]
    fn test_focus_cycle() {
        let focus = Focus::Input;
        assert_eq!(focus.next(), Focus::Chat);
        assert_eq!(focus.next().next(), Focus::Sidebar);
        assert_eq!(focus.next().next().next(), Focus::Input);
    }

    #[test]
    fn test_app_new() {
        let app = App::new(None, &UiConfig::default());
        assert!(app.running);
        assert_eq!(app.focus, Focus::Input);
        assert!(app.input.is_empty());
        assert!(app.connection_info.is_none());
        // Should have welcome message
        assert_eq!(app.messages.len(), 1);
    }

    #[test]
    fn test_app_add_message() {
        let mut app = App::new(None, &UiConfig::default());
        app.add_message(ChatMessage::User("Hello".to_string()));
        assert_eq!(app.messages.len(), 2);
        app.add_message(ChatMessage::Assistant("Hi there!".to_string()));
        assert_eq!(app.messages.len(), 3);
    }

    #[test]
    fn test_app_clear_messages() {
        let mut app = App::new(None, &UiConfig::default());
        app.add_message(ChatMessage::User("Hello".to_string()));
        app.clear_messages();
        assert!(app.messages.is_empty());
    }

    #[test]
    fn test_chat_message_type_label() {
        assert_eq!(ChatMessage::User("test".to_string()).type_label(), "You");
        assert_eq!(
            ChatMessage::Assistant("test".to_string()).type_label(),
            "Glance"
        );
        assert_eq!(ChatMessage::Error("test".to_string()).type_label(), "Error");
        assert_eq!(
            ChatMessage::System("test".to_string()).type_label(),
            "System"
        );
    }

    #[test]
    fn test_chat_scroll_sticky_behavior() {
        let mut app = App::new(None, &UiConfig::default());

        // When at bottom (scroll=0), adding message keeps us at bottom
        app.chat_scroll = 0;
        app.add_message(ChatMessage::User("Hello".to_string()));
        assert_eq!(app.chat_scroll, 0);
        assert!(!app.has_new_messages);

        // When scrolled up, adding message sets has_new_messages flag
        app.chat_scroll = 5;
        app.add_message(ChatMessage::User("World".to_string()));
        assert_eq!(app.chat_scroll, 5); // Scroll position preserved
        assert!(app.has_new_messages);
    }

    #[test]
    fn test_chat_scroll_reset_on_clear() {
        let mut app = App::new(None, &UiConfig::default());
        app.chat_scroll = 5;
        app.clear_messages();
        assert_eq!(app.chat_scroll, 0);
    }

    #[test]
    fn test_query_log_entry_success() {
        let entry = QueryLogEntry::success(
            "SELECT * FROM users".to_string(),
            Duration::from_millis(42),
            10,
        );
        assert_eq!(entry.status, QueryStatus::Success);
        assert_eq!(entry.row_count, Some(10));
        assert!(entry.error.is_none());
    }

    #[test]
    fn test_query_log_entry_error() {
        let entry = QueryLogEntry::error(
            "SELECT * FROM nonexistent".to_string(),
            Duration::from_millis(5),
            "relation does not exist".to_string(),
        );
        assert_eq!(entry.status, QueryStatus::Error);
        assert!(entry.row_count.is_none());
        assert_eq!(entry.error, Some("relation does not exist".to_string()));
    }

    #[test]
    fn test_query_log_entry_cancelled() {
        let entry = QueryLogEntry::cancelled_with_source(
            "SELECT * FROM users".to_string(),
            QuerySource::Manual,
        );
        assert_eq!(entry.status, QueryStatus::Cancelled);
        assert!(entry.row_count.is_none());
        assert!(entry.error.is_none());
    }

    #[test]
    fn test_query_log_entry_sql_preview() {
        let entry = QueryLogEntry::success(
            "SELECT id, name, email FROM users WHERE active = true".to_string(),
            Duration::from_millis(10),
            5,
        );
        // Should truncate at 30 chars
        assert_eq!(entry.sql_preview(30), "SELECT id, name, email FROM us");
        // Short preview
        assert_eq!(entry.sql_preview(10), "SELECT id,");
        // Full text if under limit
        let short_entry =
            QueryLogEntry::success("SELECT 1".to_string(), Duration::from_millis(1), 1);
        assert_eq!(short_entry.sql_preview(30), "SELECT 1");
    }

    #[test]
    fn test_app_add_query_log() {
        let mut app = App::new(None, &UiConfig::default());
        assert!(app.query_log.is_empty());

        let entry1 = QueryLogEntry::success("SELECT 1".to_string(), Duration::from_millis(10), 1);
        app.add_query_log(entry1);
        assert_eq!(app.query_log.len(), 1);

        let entry2 = QueryLogEntry::success("SELECT 2".to_string(), Duration::from_millis(20), 1);
        app.add_query_log(entry2);
        assert_eq!(app.query_log.len(), 2);
        // Most recent should be first
        assert_eq!(app.query_log[0].sql, "SELECT 2");
        assert_eq!(app.query_log[1].sql, "SELECT 1");
    }

    #[test]
    fn test_app_query_selection_navigation() {
        let mut app = App::new(None, &UiConfig::default());

        // Add some queries
        app.add_query_log(QueryLogEntry::success(
            "Q1".to_string(),
            Duration::from_millis(1),
            1,
        ));
        app.add_query_log(QueryLogEntry::success(
            "Q2".to_string(),
            Duration::from_millis(1),
            1,
        ));
        app.add_query_log(QueryLogEntry::success(
            "Q3".to_string(),
            Duration::from_millis(1),
            1,
        ));

        // Initially no selection
        assert!(app.selected_query.is_none());

        // Select first (most recent)
        app.select_next_query();
        assert_eq!(app.selected_query, Some(0));

        // Move down
        app.select_next_query();
        assert_eq!(app.selected_query, Some(1));

        // Move up
        app.select_previous_query();
        assert_eq!(app.selected_query, Some(0));

        // Can't go above 0
        app.select_previous_query();
        assert_eq!(app.selected_query, Some(0));

        // Move to last
        app.select_next_query();
        app.select_next_query();
        assert_eq!(app.selected_query, Some(2));

        // Can't go past last
        app.select_next_query();
        assert_eq!(app.selected_query, Some(2));
    }

    #[test]
    fn test_app_query_detail_modal() {
        let mut app = App::new(None, &UiConfig::default());
        app.add_query_log(QueryLogEntry::success(
            "SELECT 1".to_string(),
            Duration::from_millis(1),
            1,
        ));

        // Can't open modal without selection
        assert!(!app.show_query_detail);
        app.open_query_detail();
        assert!(!app.show_query_detail);

        // Select and open
        app.select_next_query();
        app.open_query_detail();
        assert!(app.show_query_detail);

        // Close
        app.close_query_detail();
        assert!(!app.show_query_detail);
    }

    #[test]
    fn test_app_selected_query_entry() {
        let mut app = App::new(None, &UiConfig::default());
        app.add_query_log(QueryLogEntry::success(
            "SELECT 1".to_string(),
            Duration::from_millis(1),
            1,
        ));

        // No selection
        assert!(app.selected_query_entry().is_none());

        // With selection
        app.selected_query = Some(0);
        let entry = app.selected_query_entry();
        assert!(entry.is_some());
        assert_eq!(entry.unwrap().sql, "SELECT 1");
    }

    #[test]
    fn test_history_selection_navigation() {
        let mut app = App::new(None, &UiConfig::default());

        // Add some history
        app.input_history.push("query1".to_string());
        app.input_history.push("query2".to_string());
        app.input_history.push("query3".to_string());

        // Open history selection
        app.open_history_selection();
        assert!(app.history_selection.is_some());
        let state = app.history_selection.as_ref().unwrap();
        assert_eq!(state.entries.len(), 3);
        assert_eq!(state.selected, 0);

        // Navigate down
        app.history_select_next();
        assert_eq!(app.history_selection.as_ref().unwrap().selected, 1);

        // Navigate up
        app.history_select_previous();
        assert_eq!(app.history_selection.as_ref().unwrap().selected, 0);

        // Close
        app.close_history_selection();
        assert!(app.history_selection.is_none());
    }

    #[test]
    fn test_load_selected_history() {
        let mut app = App::new(None, &UiConfig::default());

        // Add some history
        app.input_history.push("SELECT 1".to_string());
        app.input_history.push("SELECT 2".to_string());

        // Open and select
        app.open_history_selection();
        app.history_select_next(); // Select second entry

        // Load selected
        let loaded = app.load_selected_history();
        assert_eq!(loaded, Some("SELECT 2".to_string()));
        assert_eq!(app.input.text, "SELECT 2");
        assert_eq!(app.input.cursor, 8);
        assert!(app.history_selection.is_none()); // Should close after loading
    }

    #[test]
    fn test_masked_input_state() {
        let mut app = App::new(None, &UiConfig::default());

        // Start masked input
        app.start_masked_input("/llm key".to_string(), "Enter API Key".to_string());
        assert!(app.masked_input.is_some());
        let state = app.masked_input.as_ref().unwrap();
        assert_eq!(state.command, "/llm key");
        assert_eq!(state.value, "");
        assert_eq!(state.cursor, 0);

        // Cancel masked input
        app.cancel_masked_input();
        assert!(app.masked_input.is_none());
    }

    #[test]
    fn test_masked_input_flow() {
        let mut app = App::new(None, &UiConfig::default());

        // Start masked input
        app.start_masked_input("/llm key".to_string(), "Enter API Key".to_string());

        // Simulate typing (this would normally be done via handle_masked_input_key)
        if let Some(state) = &mut app.masked_input {
            state.value = "secret123".to_string();
            state.cursor = 9;
        }

        // Submit
        let result = app.submit_input();
        assert_eq!(result, Some("/llm key secret123".to_string()));
        assert!(app.masked_input.is_none()); // Should be cleared after submission
    }

    #[test]
    fn test_secret_warning_dismiss() {
        let mut app = App::new(None, &UiConfig::default());

        // Set up warning state
        app.secret_storage_status = SecretStorageStatus::PlaintextConsented;
        app.secret_warning_dismissed = false;

        // Dismiss warning
        app.dismiss_secret_warning();
        assert!(app.secret_warning_dismissed);
    }
}
