# Scalability Review

## Findings
- **High – Persisted LLM model is ignored at runtime** (`src/llm/factory.rs:18-45`, `src/app.rs:126-149`, `src/persistence/llm_settings.rs:66-104`, `src/commands/handlers/llm_settings.rs:10-49`): `/llm model` writes to SQLite and reports success, but `create_client` always pulls the model from env vars and `create_llm_client` never passes the stored model. Adding models, per-provider defaults, or per-tenant overrides would mean touching multiple layers and still would not be honored without a factory refactor.
- **High – Two independent NL→SQL pipelines** (`src/app.rs:576-720` vs `src/llm/service.rs:55-187`): Tool invocation, prompt caching, and saved-query lookups are duplicated. Any new tool, telemetry, or safety step must be added twice to keep chat and headless paths in sync, which is easy to miss and makes future behavior changes risky.
- **Medium – Provider/key wiring sits in the orchestrator instead of the LLM layer** (`src/app.rs:126-177`, `src/app.rs:449-574`): The app shell reaches directly into persistence to resolve providers and secrets, then rebuilds clients itself. Adding a provider or secret strategy requires edits across UI, orchestrator, and factory rather than just extending the LLM module, slowing experimentation and alternative frontends.
- **Medium – State DB limited to a single SQLite connection** (`src/persistence/mod.rs:104-121`): The pool is hard-capped at `max_connections(1)` while it fronts history logging, saved queries, settings, and tool calls. As more async work happens (e.g., streaming, background logging, multiple tool calls), this serializes access and will become a UI latency bottleneck.
- **Medium – Connection commands hard-code Postgres defaults** (`src/commands/router.rs:38-115`, `src/commands/handlers/connection.rs:140-217`): `/conn add` and `/conn edit` don’t expose backend selection and always persist `DatabaseBackend::default()`. Supporting another backend would require expanding parser, persistence, and connection factories rather than plugging in a new client, constraining future database support.
