# v0.2d Implementation Plan

Status: Partially implemented. Actor pattern, queue depth, and streaming exist, but v0.2d is not complete.

## Gaps vs v0.2d spec

### Actor/Protocol
- CancelCurrent is not responsive because requests run inline in the actor loop; cancel commands are handled only after the request finishes.
- OperationPhase and Progress (phase + elapsed) are missing; only basic progress messages are sent.
- Queue should pause while awaiting confirmation; current actor continues processing the queue after NeedsConfirmation.
- Queue position updates are missing; QueueUpdate only contains depth/current.
- Channel error handling and reconnection logic are missing.

### UI/Behavior
- No per-request placeholders or inline state; only a global spinner is rendered.
- Queue indicator in the header/status bar is missing.
- Input states for queue-full and confirmation prompt are missing.
- Cancel queued request via navigation + x/Delete is missing.
- Cancel-all confirmation (when multiple pending) is missing.
- Partial results on cancel are discarded instead of preserved.

## Implementation Plan

### Phase 1: Actor concurrency + phase/elapsed
1. Refactor `src/tui/orchestrator_actor.rs` to run requests in spawned tasks, and `tokio::select!` over receiver + in-flight task.
2. Add `OperationPhase` and `OrchestratorResponse::Progress { id, phase, elapsed, detail }`.
3. Track request start times and emit phase transitions; add a 100ms interval for elapsed updates.
4. Make CancelCurrent and CancelRequest responsive by canceling tokens immediately and aborting in-flight task if needed.

### Phase 2: Confirmation gating + queue updates
1. Add `awaiting_confirmation` flag and pause `process_next` while true.
2. Extend `QueueUpdate` to include queue snapshot or per-request positions.
3. Update the actor to emit position updates on enqueue/dequeue/cancel.

### Phase 3: TUI placeholders + header queue indicator
1. Add per-request pending entries in `src/tui/app.rs` keyed by RequestId.
2. Render pending placeholders in `src/tui/widgets/chat.rs` with phase text and elapsed time.
3. Pass queue depth into `src/tui/widgets/header.rs` and render “Queue: N”.

### Phase 4: Input states + cancel UX
1. Disable input when queue is full and show “Queue full” message.
2. Show confirmation prompt in input field during `NeedsConfirmation` (or a modal prompt that blocks input).
3. Add selection for pending items and wire x/Delete to cancel queued requests.
4. Add cancel-all confirmation modal when multiple pending.
5. Preserve partial streamed content and append a “Cancelled” marker instead of clearing.

### Phase 5: Channel errors + recovery
1. Detect closed response/progress channels in `src/tui/mod.rs`.
2. Show a toast and attempt to respawn the actor up to 3 times.
3. If reconnection fails, show a modal with “Retry” / “Exit”.

## Tests to add/update
- Actor: FIFO order, max depth, cancellation responsiveness, confirmation gating.
- TUI: placeholders update by phase and elapsed; queue indicator; input disabled when full.
- Recovery: channel close triggers retry logic.

## Notes
- Keep queue depth (10) configurable if requested; otherwise hardcode per spec.
- Ensure non-blocking UI by avoiding synchronous waits in the event loop.

## Implementation Plan (thorough)

### Phase 0 - Recon and alignment
- Re-read `docs/specs/v0.2d.md` and map each FR/US to current code paths in `src/tui/orchestrator_actor.rs`, `src/tui/mod.rs`, `src/tui/app.rs`, `src/tui/ui.rs`, and `src/tui/widgets/*`.
- Decide the UI data model for per-request placeholders (new `ChatMessage` variant vs a parallel pending list) before refactoring; prefer a structure that can track `RequestId`, phase, elapsed, queue position, and streaming text.
- Decide whether progress lives on the response channel (`OrchestratorResponse::Progress`) only, or if the existing `ProgressMessage` channel is retained with request-scoped payloads.
- Confirm how confirmation should map to request IDs (spec ties confirmation to the original request; current TUI creates a new ID).

### Phase 1 - Actor concurrency and phase/elapsed model
1) Restructure the actor loop to avoid inline request execution
   - In `src/tui/orchestrator_actor.rs`, spawn request handling in a task and track it via a `JoinHandle` plus a completion channel or task result message.
   - Use `tokio::select!` to interleave command handling with in-flight completion and progress ticks; bias toward commands for responsive cancels.
2) Add `OperationPhase` and progress responses
   - Define `OperationPhase` and `OrchestratorResponse::Progress { id, phase, elapsed, detail }`.
   - Track `queued_at`, `started_at`, and `phase_started_at` in actor state to drive elapsed updates every 100ms.
3) Make cancellation responsive
   - Store `CancellationToken` and (optionally) `AbortHandle` for the in-flight task.
   - On `CancelCurrent`, cancel token immediately and abort if needed; ensure actor loop is not blocked by the task.
4) Confirmation gating
   - Add an `awaiting_confirmation` flag in the actor that pauses `process_next` while true.
   - When sending `NeedsConfirmation`, keep the request ID in actor state; require `ConfirmQuery`/`CancelPendingQuery` to resolve it before resuming the queue.

### Phase 2 - Queue management and position updates
1) Extend queue update payloads
   - Update `OrchestratorResponse::QueueUpdate` to include per-request positions (e.g., `Vec<(RequestId, position)>`) and `max_depth` so the UI can show queue status accurately.
2) Emit position updates on every change
   - Send `QueueUpdate` on enqueue, dequeue, cancel, and confirmation resolve; ensure queued positions are recomputed after removals.
3) Fix ignored queue tests
   - In `src/tui/orchestrator_actor.rs` tests, remove the race by holding an in-flight request (e.g., mock LLM sleep) so queued items remain queued and positions are stable.

### Phase 3 - App state for per-request placeholders
1) Add per-request view model
   - In `src/tui/app.rs`, add a `PendingRequestView` (id, phase, queued_at, started_at, position, detail, streaming_text, status).
   - Maintain `pending_by_id: HashMap<RequestId, PendingRequestView>` and a stable ordering list to render placeholders inline in chat.
2) Make streaming request-scoped
   - Replace `streaming_assistant_index` with request-scoped streaming buffers; update `append_streaming_token` to target a request ID.
   - Preserve partial content on cancel by keeping the streaming text and appending a "Cancelled" marker instead of clearing it.
3) Track queue + confirmation state in App
   - Move `queue_depth` into `App` so widgets can render it; add `queue_full` and `awaiting_confirmation` flags.
   - Extend `PendingQuery` to include `RequestId` so confirm/cancel targets the correct request.

### Phase 4 - UI rendering updates
1) Chat placeholders
   - In `src/tui/widgets/chat.rs`, render pending entries with phase text and elapsed time (>= 1s), plus queue position for queued items.
   - Add visual distinction for queued vs running vs cancelled/error (simple text labels and existing spinner frames).
2) Header queue indicator
   - Update `src/tui/widgets/header.rs` to accept queue depth (and possibly pending count) and render "Queue: N" on the right.
   - Update `src/tui/ui.rs` to pass the new fields from `App`.
3) Input states
   - Update `src/tui/widgets/input.rs` to support disabled rendering and prompt overrides ("Queue full", "[y/n]").
   - In `src/tui/ui.rs`, pass down the state so the input bar can render accordingly (and optionally hide the cursor when disabled).
4) Help overlay
   - Update `src/tui/widgets/help.rs` to include cancel-all confirmation, cancel queued (x/Delete), and any new navigation keys.

### Phase 5 - Event loop and interaction wiring
1) Submission and placeholder creation
   - In `src/tui/mod.rs`, when submitting input, add a placeholder for the new request ID and keep input enabled unless the queue is full.
2) Handle new response types
   - Add handling for `Progress` (phase/elapsed updates) and enriched `QueueUpdate` to update pending view state.
   - Use `NeedsConfirmation` to set the pending query (with request ID) and pause input until resolved.
3) Confirmation flow
   - Confirm uses the original request ID in `ConfirmQuery` rather than creating a new one.
   - Canceling confirmation triggers `CancelPendingQuery` (updated to include request ID) and resumes queue processing.
4) Cancel queued requests
   - Add a selection mechanism for pending items in `App` (e.g., `pending_selected: Option<RequestId>`).
   - Wire x/Delete to call `cancel_request(id)`; show a brief toast on cancel.
5) Cancel-all confirmation
   - When multiple pending exist and Ctrl+C is pressed, show a modal or input prompt; only send `CancelAll` on explicit confirmation.
6) `is_processing` semantics
   - Keep `app.is_processing` true while any request is pending or in-flight so headless assertions remain meaningful.

### Phase 6 - Channel errors and recovery
1) Detect channel closure
   - In `run_event_loop`, handle `None` from `response_rx.recv()` and `progress_rx.recv()` as a disconnect signal.
2) Actor restart path
   - Cache what is needed to rebuild the orchestrator (connection config + provider) and respawn the actor up to 3 times.
   - Show a toast on reconnect attempts; after 3 failures, render a modal with "Retry" / "Exit".
3) State cleanup on disconnect
   - Cancel all pending tokens, mark placeholders as cancelled, and clear any in-flight selection state before retrying.

### Phase 7 - Tests and fixtures
- Actor tests: add coverage for responsive cancel, confirmation gating, progress emission cadence, queue position updates.
- TUI tests: add widget tests for placeholder rendering and elapsed formatting; update any existing snapshot tests.
- Headless: update `src/tui/headless` state assertions if fields change; adjust fixtures that rely on spinner-only output.
- Manual verification: multi-queue submission, cancel current vs queued, confirm mutation while queue pauses, queue-full input disabled, reconnect behavior.

### Phase 8 - Cleanup and polish
- Remove or scope global spinner usage once per-request placeholders are stable.
- Ensure no duplicate progress UI (avoid both spinner and placeholder for the same request).
- Update `docs/TESTING.md` or `docs/IMPLEMENTATION_PLAN.md` if new manual steps are needed.
